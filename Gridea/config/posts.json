{
  "posts": [
    {
      "content": "元组：tuple\ntuple和list非常相似，但是tuple一旦初始化就不能修改\ntuple获取元素的方法与list一样，通过索引获取\n定义一个空的tuple：\n```\nt = ()\n```\n但是要定义一个只有一个元素的tuple，必须加一个逗号，来消除歧义\n```\nt = (1,)\n```\n“可变的”tuple\n```\nIn[]：\nt = ('a','b',['python','java'])\nprint(t)\nt[2][1] = 'php'\nprint(t)\nOut[]：\n('a', 'b', ['python', 'java'])\n('a', 'b', ['python', 'php'])\n```\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python元组及其常用操作",
        "date": "2019-08-29 13:57:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-yuan-zu-ji-qi-chang-yong-cao-zuo"
    },
    {
      "content": "# 概念\n在其他语言里，会叫这种数据类型为数组，array，在python里，我们叫列表，list\n列表是一种数据结构\n列表是一个序列，用于顺序的存储数据。\n序列是python中最基本的数据结构。\n序列中的每个元素都分配一个数字：索引\n```\nl = list()\nl = []\nl = [1,2,3]\nl = list(range(1,10))\n```\n通常在定义列表的时候用\\[]，在转化可迭代对象为列表的时候用list函数\n# 访问列表\n定义一个1-9的列表\n```\nl = list(range(1,10))\n```\n通过下标访问，下标从0开始\n```\nl[0]\n```\n当下标超出范围时，会抛出IndexError\n```\nl[100]\n```\n负数索引从右边开始，并且索引从-1开始\n## list.index\n也可以通过help函数查看所有方法的函数签名，也就是函数说明\n```\nIn[]：help(list.index)\nOut[]：\nHelp on method_descriptor:\nindex(self, value, start=0, stop=9223372036854775807, /)\n    Return first index of value.\n    Raises ValueError if the value is not present.\n```\n这里函数签名中，stop有个默认值，也就是到列表哪一个位置结束，这也是它的最大值了，超出了可能就内存溢出。\n\"list.index\"方法返回查找到的第一个索引\n```\nl = list(range(1,10))\nl.index(4)\nnew_l = [1,2,3,2,4,3,5]\nnew_l.index(2)\nnew_l.index(2,2,3)\nnew_l.index(2,-1)\nnew_l.index(2,-4,-1)\n```\nlist.index的start和end参数可以为负数，但是在查找过程中还是从左到右的顺序\n当查找不到元素时，抛出错误ValueError。\n### list.index函数解读\n实现list.index函数：\n```\ndef index(lst,val,start=0,end=-1):\n    i = start\n    for x in lst[start:end]:\n        if x == val:\n            return i\n        i += 1\n    raise ValueError()\n```\n## list.count\n查看一下list.count的函数签名\n```\nIn[]：help(list.count)\nOut[]：\nHelp on method_descriptor:\ncount(self, value, /)\n    Return number of occurrences of value.\n```\nlist.count，统计你要查询的字符在列表里出现的次数\n```\nnew_l = [1,2,3,2,4,3,5]\nnew_l.count(5)\nnew_l.count(10)\n```\n### list.count函数解读\n实现list.count函数：\n```\ndef count(lst,value):\n    c = 0\n    for x in lst:\n        if x == value:\n            c += 1\n    return c\n```\n## 总结\n* list通过索引访问元素\n* index方法根据值返回第一个索引\n* count方法返回元素在列表里的个数\n\nindex和count的时间复杂度是O(n)\n# 列表修改\n通过索引的方式进行赋值即可\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l[2] = 5\nprint(new_l)\nOut[]：\n[1, 2, 5, 2, 4, 3, 5]\n```\n超出范围还是会抛出IndexError\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l[10] = 10\nOut[]：\nIndexError                                Traceback (most recent call last)\n<ipython-input-3-daf879895697> in <module>\n      1 new_l = [1,2,3,2,4,3,5]\n----> 2 new_l[10] = 10\nIndexError: list assignment index out of range\n```\n# 列表增加\n## list.append\n先用help函数看下它的函数签名\n```\nIn[]：\nhelp(list.append)\nOut[]：\nHelp on method_descriptor:\nappend(self, object, /)\n    Append object to the end of the list.\n```\nappend**原地修改list，返回值是None**,直接在最后加一位，我们称之为追加\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.append(99)\nprint(new_l)\nOut[]：\n[1, 2, 3, 2, 4, 3, 5, 99]\n```\n## list.insert\n在第i个元素前插入e\n```\nIn[]：\nhelp(list.insert)\nOut[]：\nHelp on method_descriptor:\ninsert(self, index, object, /)\n    Insert object before index.\n```\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(1,99)\nprint(new_l)\nOut[]：\n[1, 99, 2, 3, 2, 4, 3, 5]\n```\n**当越界的时候，自动往左或往右插入该值，这点非常重要，它并不会报错**\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(100,99)\nprint(new_l)\nOut[]：\n[1, 2, 3, 2, 4, 3, 5, 99]\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(-100,99)\nprint(new_l)\nOut[]：\n[99, 1, 2, 3, 2, 4, 3, 5]\n```\nappend和insert的效率：\n* append的时间复杂度是O(1)，常数时间，效率和数据的规模无关\n* insert的时间复杂度是O(n)，线性时间，效率和数据规模线性相关\n\n**尽量使用append**\n## list.extend\nextend将任意可迭代对象追加到数据的末尾，**原地修改，返回None**\n```\nIn[]：\nhelp(list.extend)\nOut[]：\nHelp on method_descriptor:\nextend(self, iterable, /)\n    Extend list by appending elements from the iterable.\n```\n值得注意的是，extend是把可迭代对象里的每一个值循环append到list里去，而不是像append，直接把一整个对象追加到列表的队尾\n* append操作单个元素\n* extend操作可迭代对象\n\n对比栗子：\n```\nIn[]：\nnew_l = [0,1,2]\nnew_l.append([1,2,3])\nprint(new_l)\nOut[]：\n[0, 1, 2, [1, 2, 3]]\nIn[]：\nnew_l = [0,1,2]\nnew_l.extend([1,2,3])\nprint(new_l)\nOut[]：\n[0, 1, 2, 1, 2, 3]\n```\n**list.extend经常用在两个列表的相加上**\n## list + list\n两个列表的相加还可以直接用加号\n```\nIn[]：\nl = [0,1,2,3,4]\na = l + ['a','b','c']\nprint('a:',a)\nprint('l:',l)\nOut[]：\na: [0, 1, 2, 3, 4, 'a', 'b', 'c']\nl: [0, 1, 2, 3, 4]\n```\n**这种方法有返回值，但是不修改list本身，返回一个新的list**，这种操作叫list的连接操作\n# 列表删除\n## list.remove\n```\nIn[]：\nhelp(list.remove)\nOut[]：\nHelp on method_descriptor:\nremove(self, value, /)\n    Remove first occurrence of value.\n    Raises ValueError if the value is not present.\n```\n删除第一个匹配的元素\n```\nIn[]：\nl = [1,2,3,2,3,4,3,5,3,4]\nl.remove(2)\nprint(l)\nOut[]：\n[1, 3, 2, 3, 4, 3, 5, 3, 4]\n```\n**原地修改，返回None，根绝值删除元素**\n当值不存在时，抛出ValueError\n```\nIn[]：\nl = [1,2,3,2,3,4,3,5,3,4]\nl.remove(10)\nOut[]：\nValueError                                Traceback (most recent call last)\n<ipython-input-5-13fc432ba077> in <module>\n      1 l = [1,2,3,2,3,4,3,5,3,4]\n----> 2 l.remove(10)\nValueError: list.remove(x): x not in list\n```\n## list.pop\n```\nIn[]：\nhelp(list.pop)\nOut[]：\nHelp on method_descriptor:\npop(self, index=-1, /)\n    Remove and return item at index (default last).\n    Raises IndexError if list is empty or index is out of range.\n```\n不传入参数，则默认返回并删除最后一个值\n传入index参数，返回并删除index所在的值\n```\nIn[]：\nl = [3,2,4,3,5,3,4]\nl.pop(3)\nprint(l)\nOut[]：\n3\n[3, 2, 4, 5, 3, 4]\n```\n**注意：这个传入的参数是index，不是元素的值**\n当索引不存在时，抛出IndexError\n```\nIn[]：\nl = [3,2,4,3,5,3,4]\nl.pop(100)\nOut[]：\nIndexError                                Traceback (most recent call last)\n<ipython-input-10-85aba9b20ee8> in <module>\n      1 l = [3,2,4,3,5,3,4]\n----> 2 l.pop(100)\nIndexError: pop index out of range\n```\n这里需要注意几点：\n* pop不传递index参数，时间复杂度是O(1)\n* pop传递index参数，时间复杂度是O(n)\n* pop根据索引删除元素，并且返回删除的元素\n* remove根据值删除元素，返回None\n\n## list.clear\n```\nIn[]：\nhelp(list.clear)\nOut[]：\nHelp on method_descriptor:\nclear(self, /)\n    Remove all items from list.\n```\n删除所有元素\n```\nIn[]：\nl = [3,2,3,5,3,4]\nl.clear()\nprint(l)\nOut[]：\n[]\n```\n使用clear后，列表对象还存在，只是里面的值都被清空了\n# 其它操作\n## 求list的长度\nlen(l)\n```\nIn[]：\nl = [3,2,3,5,3,4]\nlen(l)\nOut[]：\n6\n```\n## 反转列表\nl.reverse()\n```\nIn[]：\nl = [0,1,2,3,4,5,6]\nl.reverse()\nprint(l)\nOut[]：\n[6, 5, 4, 3, 2, 1, 0]\n```\n## 列表排序\nl.sort()\n```\nIn[]：\nl = [2,5,3,6,1,4,8,9]\nl.sort()\nprint(l)\nOut[]：\n[1, 2, 3, 4, 5, 6, 8, 9]\n```\n**原地修改，返回None**\n**逆序排序，l.sort(reverse=True)**\n```\nIn[]：\nl = [2,5,3,6,1,4,8,9]\nl.sort(reverse=True)\nprint(l)\nOut[]：\n[9, 8, 6, 5, 4, 3, 2, 1]\n```\n## 列表拷贝\n### 引用传递\n```\nIn[]：\na = [1,2,3]\nb = a\nprint(b)\nb[1] = 99\nprint(b)\nprint(a)\nOut[]：\n[1, 2, 3]\n[1, 99, 3]\n[1, 99, 3]\n```\n### 浅复制（浅拷贝）\n```\nIn[]：\nl = [1,2,3,4,5]\nl2 = l.copy()\nl2[0] = 'a'\nprint(l)\nprint(l2)\nOut[]：\n[1, 2, 3, 4, 5]\n['a', 2, 3, 4, 5]\n```\n如果列表存在嵌套列表\n```\nIn[]：\nl = [1,[1,2,3],4]\nl2 = l.copy()\nl2[1][1] = 'a'\nprint(l2)\nprint(l)\nOut[]：\n[1, [1, 'a', 3], 4]\n[1, [1, 'a', 3], 4]\n```\n### 深复制（深拷贝）\n使用深拷贝需要引入copy模块，使用deepcopy\n```\nIn[]：\nfrom copy import deepcopy\nl = [1, [1, 'a', 3], 4]\nl2 = deepcopy(l)\nl2[1][1] = 'b'\nprint(l2)\nprint(l)\nOut[]：\n[1, [1, 'b', 3], 4]\n[1, [1, 'a', 3], 4]\n```\n\n\n\n\n\n",
      "data": {
        "title": "Python列表及其常用操作",
        "date": "2019-08-28 14:07:15",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-nei-zhi-shu-ju-jie-gou"
    },
    {
      "content": "# 常量变量 & 类型系统\n## 常量变量\n常量：一旦赋值，就不能改变它的值。也就是说不能对它进行重新赋值。\n变量：是一个名字，在赋值符号的左边，这个名字可以指代赋值符号右边的内容。\n注意：Python不存在常量。因为Python一切皆对象，Python赋值即定义。\n## 类型系统\npython是门强类型的动态语言，但它同时又是一门解释性语言。\n那么作为强类型语言，python就有自己的类型系统，python的类型系统分为基本类型和内置数据结构。\n基本类型分为：\n* int\n* float\n* bool\n* None\n\nstr、list、dict等在官方文档中查到，隶属于：built-in structure。\n内置数据结构分为：\n* str\n* list\n* tuple\n* set\n* dict\n* bytes\n* bytearray\n\n动态语言指一个变量的类型可以被多次修改、赋值。\n而在java、c#这种静态语言中，一旦定义了一个变量\n```\nstring strA = 'a'\n```\n就无法改变它的类型了，只能改变值。\n# 基本数据类型\n## 整型和浮点型\n在python2里区分整型和长整型，python3里不区分，只有整型。\n对于int来说，不存在溢出。\n但float会溢出，会损失精度，这也就是我们常说的精度失效。\n举个简单的栗子：\n```\nIn[1]：3.3 * 6\nOut[1]：19.799999999999997\n```\n### 为什么会有精度失效\n因为计算机都是用二进制表示的，那么势必会存在0和1之间的数字没法表示。\n### 二进制小数转十进制小数\n采用方法：按权展开求和法\n举个栗子：将101.111(2)这个二进制小数转换成十进制数。\n计算：1*(2^2)+0*(2^1)+1*(2^0)+1*(2^(-1))+1*(2^(-2))+1*(2^(-3))=5.875\n### 十进制小数转二进制小数\n十进制数的整数位是二进制数的整数位，十进制数的小数位是二进制数的小数位\n假如有小数111.4(10)，进行计算\n小数位采用“乘二取整法”（顺序排列），取整就是取整数位上的数字\n| 乘二 |  取整 |\n| - | - |\n| 0.4\\*2=0.8 | 0 |\n| 0.8\\*2=1.6 | 1 |\n| 0.6\\*2=1.2 | 1 |\n| 0.2\\*2=0.4 | 0 |\n| 0.4\\*2=0.8 | 0 |\n| 0.8\\*2=1.6 | 1 |\n| 0.6\\*2=1.2 | 1 |\n| 0.2\\*2=0.4 | 0 |\n经过计算发现出现了循环，0.01100110...(循环0110)\n整数位采用“除二取余法”（逆序排列）\n| 除二 | 商 | 余数 |\n| - | - | - |\n| 111/2 | 55 | 1 |\n| 55/2 | 27 | 1 |\n| 27/2 | 13 | 1 |\n| 13/2 | 6 | 1 |\n| 6/2 | 3 | 0 |\n| 3/2 | 1 | 1 |\n| 1/2 | 0 | 1 |\n所以整数位是1101111\n最终结果是整数位和小数位合并1101111.01100110......\n### 代码\n从代码角度出发，如何规避这类情况？那就要用到经常提到的一个概念：“精确到小数点后面多少位”\n```\nfrom decimal import Decimal\nfrom decimal import getcontext\ngetcontext().prec = 8\nIn[]：Decimal(3.3) * Decimal(6)\nOut[]：Decimal('19.800000')\n```\n## None\nNone就是一个类型，在js里面有undefined和null，但是python只有一个None。\nNone既不是空字符串，也不是未定义\nNone在判断语句中位False，但None不等于False\n```\nIn[]：None == False\nOut[]：False\n```\n## Bool\nBool就是True or False。\n## 总结\n基本数据类型一共有4种，int、float、bool、None\n# 运算符\n## 算数运算符\n* \\+\n* \\-\n* \\*\n* \\/\n* \\//\n* \\**\n* \\%\n\n以上就是python运算符，但是要注意：只能对int和float做运算。\n特别说明：\n/运算符在python3是自然除，python2是整除\n## 比较运算符\n* \\>\n* \\<\n* \\=\n* \\!=\n* \\>=\n* \\<=\n\n所有比较运算符的返回值都是bool类型\n## 逻辑运算符\n* and\n* or\n* not\n\n逻辑运算符的两边必须是True或False\n注意：逻辑运算符的短路\nor运算，只要执行到第一个位true的时候之后就不执行了。\n## 成员运算符\n* in\n* not in\n\n## 身份运算符\n* is\n* is not\n\n## 位运算符\n* \\<<\n* \\>>\n* &\n* |\n* ^ 异或\n\n位运算符用在哪里呢？\n### 判断奇偶数\n我们可以利用&运算符的特性来判断二进制数最后一位是0还是1。\n用if((a&1) == 0)代替if(a%2 == 0)来判断a是不是偶数。\n### 交换两个数\n先了解一下^的几个特性\n* a^a = 0\n* a^0 = a\n* (a^b)^c = a^(b^c)\n\n交换两个数的方法为：\n```\na ^= b\nb ^= a\na ^= b\n```\n从数学角度分析一下：\na = a ^ b\nb = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a\na = a ^ b = (a ^ b) ^ b = (a ^ a) ^ b = b ^ 0 = b\n## 赋值运算符\n* i += 3\n* i \\*= 3\n\n所有的算术运算符都可以和赋值运算符一起使用。\n# 表达式 & 程序结构\n## 表达式 & 语句\n表达式：常量/变量和运算符一起构成，表达式有返回值\n语句：关键字和表达式一起构成，语句没有返回值\n## 顺序结构\n就是代码从上到下，一行一行执行\n## 分支结构\n### 单分支\n单分支只有一个操作，条件成立去做操作，然后结束，否则直接结束。\n```\na = 5\nif a < 10:\n    print('a less than 10')\nprint(a)\n```\n### 双分支\n双分支就是当条件不成立的时候还多了一个操作，方便做逻辑处理。\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelse:\n    print('a is not less than 10')\nprint(a)\n```\n双分支结构永远只有一个条件会被执行\n### 嵌套\n嵌套的意思就是，在if里面还可以有if\n通过结构嵌套实现多分支\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelse:\n    if a < 20:\n        print('10 <= a < 20')\n    else:\n        print('a is not less than 10')\nprint(a)\n```\n### 关键字elif\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelif a < 20:\n    print('10 <= a < 20')\nelse:\n    print('a is not less than 10')\nprint(a)\n```\n对于分支结构来说，总结一下就是：\n1. 分支结构永远只有1个或者0个分支会被执行\n2. 分支结构中所有条件是互斥的\n3. 条件只能是bool类型或者可以隐式转换为bool类型\n## 循环结构\n### while\nwhile循环需要一个条件支撑，如果条件为True，循环将继续。\n### for in\npython的for循环和其他语言不一样，在for关键字里实现了一个迭代协议，通过迭代协议完成了对可迭代对象的循环。\n#### 提前终止\n当在for循环体内，遇到break关键字的时候，将会结束本层循环，注意不是本次，是本层\n如果是两个for循环,那么就会退出本层循环，进入上层循环的下一次循环中\n```\nfor i in range(3):\n    for j in range(5):\n        print('j:' + str(j))\n        if j % 2 == 0:\n            print('i:',i,'j:',j)\n            break\n```\n#### 跳过\ncontinue是跳过本次循环，继续下一次循环，**注意这里是继续同一层的下一次循环**\n```\nfor i in range(0,3):    \n    if i % 2 != 0:\n        print(i)\n        continue\n```\n### else子句\n在python中，for循环还有一个其他语言没有的关键字，else\n这个else不是if的else，而是for的else。只有当for循环的主体循环全部结束后，才会去执行else语句。\n举个栗子：\n```\nIn[0]:\nfor i in range(10):\n    pass\nelse:\n    print('ok')\nOut[0]:ok\n```\n如果循环体被break了呢？\n```\nIn[0]:\nfor i in range(10):\n    break\nelse:\n    print('ok')\nOut[0]:\n```\n如果是continue呢？\n```\nIn[0]:\nfor i in range(10):\n    continue\nelse:\n    print('ok')\nOut[0]:ok\n```\n结论：**当循环没有提前退出时，会执行else子句**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python基本语法",
        "date": "2019-08-27 13:51:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ji-ben-yu-fa"
    },
    {
      "content": "# Git配置\nGit安装完成后需要配置个人的用户名称和邮件地址\n```\ngit config --global user.name \"yanghang\"\ngit config --global user.email yanghang0214@qq.com\n```\n查看配置信息\n```\ngit config --list\n```\n# Git创建仓库\n初始化Git仓库\n```\ngit init\n```\n将文件添加到缓存，例如添加两个文件：\n```\ngit add <file1> <file2> \n```\n或者添加所有文件，可以使用\n```\ngit add .\n```\n查看文件是否添加成功：\n```\ngit status\ngit status -s\n```\n将缓存区内容添加到仓库中：\n```\ngit commit -m '本次提交的说明'\n```\n查看文件修改了哪些内容：\n```\ngit diff readme.txt \n```\n查看git提交修改的日志：\n```\ngit log\n```\nGit版本回退，在Git中用HEAD表示当前版本，上个版本是HEAD\\^,上上个版本是HEAD\\^^，往上100个写成HEAD\\~100：\n```\ngit reset --hard HEAD^\n```\n要重返未来需要查看命令历史\n```\ngit reflog\n```\n# Git添加远程仓库\n**创建SSH Key**\n使用自己的邮件地址，一路回车使用默认值。完成后可以在**用户主目录**里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，id_rsa是私钥，id_rsa.pub是公钥。\n```\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n**在GitHub添加key**\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴**id_rsa.pub**文件的内容，点“Add Key”，你就应该看到已经添加的Key。\n**关联远程仓库**\n远程库的名字就是origin，这是Git默认的叫法，也可以改成别的\n```\ngit remote add origin git@github.com:yh0214/grideasourcecode.git\n```\n**本地推送至远程库**\n首先添加内容到缓存：git add <file1>，然后由缓存添加内容到仓库：git commit -m '本次提交的说明'；使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，可以使用命令git push origin master推送最新修改\n```\ngit push -u origin master\ngit push origin master\n```\n**从远程库克隆至本地**\n```\ngit clone git@github.com:yh0214/grideasourcecode.git\n```\n**删除github上文件**\n```\ngit rm -r --cached 文件夹名称\ngit commit -m 'delete 文件夹名称 dir'\ngit push -u origin master\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Git",
        "date": "2019-08-27 08:31:42",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git"
    }
  ],
  "tags": [
    {
      "name": "Gridea",
      "slug": "eqeFQaS7k",
      "used": false
    }
  ],
  "menus": []
}