{
  "posts": [
    {
      "content": "# 定义\n线性结构共同特点：\n* 可迭代\n* 可以用len方法获取长度\n* 可以通过索引访问\n* 可以切片\n\n# enumerate\n```\nIn[]：\nenumerate((1,2,3))\nOut[]：\n<enumerate at 0x6059750>\n```\n返回一个可迭代对象，再来看看这个可迭代对象是什么\n```\nIn[]：\nlist(enumerate((1,2,3)))\nOut[]：\n[(0, 1), (1, 2), (2, 3)]\n```\n实现一个enumerate函数\n```\nIn[]：\ndef new_enumerate(iterator):\n    i = 0\n    for v in iterator:\n        yield i,v\n        i += 1\nlist(new_enumerate((1,2,3)))\nOut[]：\n[(0, 1), (1, 2), (2, 3)]\n```\n需要同时获取索引和value时用这个函数\n# 迭代器\n可迭代对象可以通过iter方法转换为迭代器\nnext可以迭代迭代器，不可以迭代可迭代对象\n当next将迭代器的元素都迭代过一遍后，再迭代一次就会抛出StopIteration\n```\nIn[]：\nit = iter(list((1,2,3)))\nnext(it)\nOut[]：\n1\n```\n# 切片操作\nlst\\[start:stop\\]，可以访问这个list一段，从start开始，到stop结束，不包含stop，并且是原地不修改，有返回值\n* start超出索引范围时，start = 0\n* stop超出索引范围时，stop = -0\n* 当start>=stop时，返回空列表\n* 负数索引，实际上等于len(lst) + index\n\n\n```\nIn[]：\n\nOut[]：\n\n```",
      "data": {
        "title": "Python线性结构与切片",
        "date": "2019-09-03 17:29:44",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-xian-xing-jie-gou-yu-qie-pian"
    },
    {
      "content": "# 定义\n* str是文本序列\n* bytes是字节序列\n\n## 区别\n* 文本是有编码的，例如：utf8、gbk\n* 字节没有编码\n* 文本的编码指的是字符如何使用字节来表示\n\n## 编码\n* 单字节编码，例如：ascii\n* 多字节编码，例如：utf8\n\n**注意：python3中，字符串默认使用utf8编码**\n而把字符串经过编码后的数据类型，我们称为bytes\n以下这段编码就是用utf8编码表示的字节：\n```\nIn[]：\ns = '人人都是Pythonista'\ns.encode()\nOut[]：\nb'\\xe4\\xba\\xba\\xe4\\xba\\xba\\xe9\\x83\\xbd\\xe6\\x98\\xafPythonista'\n```\nbytes是可以转化成字符串的\n```\nIn[]：\ns = '人人都是Pythonista'\nbt = s.encode()\nbt.decode()\nOut[]：\n'人人都是Pythonista'\n```\n**在python3中，socket只能用bytes**\n**注意：在python2中不区分bytes和str**\n# bytes\n## bytes定义\nstr的所有操作，bytes都支持\n* bytes由str通过encode方法转化得到\n* 通过b前缀定义bytes\n\n```\nIn[]：\nbt = b'abc'\ntype(bt)\nOut[]：\nbytes\n```\n## bytes操作\nbytes的操作除了encode外，str操作都有对应bytes的版本，但是传入参数也必须是bytes，如果传入字符串会报错\n栗子（使用socket发送十六进制报文）：\n1. 将字符串转换为十六进制字节\n2. 将十六进制字节转换为字符串\n```\nIn[]：\na = 'aabbccddeeff'\na_bytes = bytes.fromhex(a)\nprint(a_bytes)\naa = a_bytes.hex()\nprint(aa)\nOut[]：\nb'\\xaa\\xbb\\xcc\\xdd\\xee\\xff'\naabbccddeeff\n```\n# bytearray\nbytearray是bytes的可变版本\nstr和bytes是不可变的\nbytearray是可变类型，进行一次替换\n```\nIn[]：\nba = bytearray(b'abc')\nba[0] = int(b'D'.hex(),16)\nba\nOut[]：\nbytearray(b'Dbc')\n```\n这里要注意几个地方\n* bytearray更新的时候，也是一个一个字节更新的，不是一个字符串\n* 要把字节转换成十六进制数进行更替\n## 使用场景\n图像处理\n修改图片时，图片保存成了字节，需要一个可变版本的bytes\n## bytearray的方法\n相对bytes来说，多了insert，append，extend，pop，remove，clear，reverse\n其实就是多了list的那些方法，并且可以索引操作\n但是和修改bytearray一样，所有的方法中，都需要用int来表示，而非bytes本身\nint必须在0~256这个范围内，即8位的无符号整数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python字符串与bytes",
        "date": "2019-09-03 16:10:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-yu-bytes"
    },
    {
      "content": "# print style字符串格式化\n通过在字符串后面追加一个百分号，再追加一个元组，元组里面加上你要组合的字符串\n传入参数顺序替换占位符，返回替换后的字符串\n```\nIn[]：\n'i use %s,i am %d' % ('python',18)\nOut[]：\n'i use python,i am 18'\n```\n**注意：当在拼接sql的时候，一定要用这种print style，%的方式可以帮助我们避免恶意攻击者sql注入**\n# format方法\nformat方法使用{}作为占位符\nformat可以在占位符里面加数字，指定format参数的位置\n```\nIn[]：\ns = 'i use {1},i am {0}'\ns.format(18,'python')\nOut[]：\n'i use python,i am 18'\n```\n参数可以通过指定位置方式多次使用\n```\nIn[]：\n'{0}{0}'.format('python')\nOut[]：\n'pythonpython'\n```\n可以在占位符里加标识符，来使用关键字参数\n```\nIn[]：\n'{who} {do} {what}'.format(who='everyone',do='use',what='python')\nOut[]：\n'everyone use python'\n```\n同时支持使用位置和关键字参数\n**位置参数必须要在前面，关键字参数在后面**\n```\nIn[]：\n'{0} {who} {do} {what}'.format('今天',who='everyone',do='use',what='python')\nOut[]：\n'今天 everyone use python'\n```\n若要打印{}，则在外面加一层{}即可\n```\nIn[]：\n'{{}}'.format()\nOut[]：\n'{}'\n```\n```\nIn[]：\n'{{{}}}'.format(18)\nOut[]：\n'{18}'\n```\n# f前缀\npython3.6开始新增了一项新的前缀，f前缀\n```\nIn[]：\nwho = 'everyone'\ndo = 'use'\nwhat = 'python'\nf'{who} {do} {what}'\nOut[]：\n'everyone use python'\n```\n当在代码块的上文中已经提及了这些变量，可以直接用f前缀加上这些变量来组合\n举个栗子：\n```\nIn[]：\ntoken = 'asdfasdfasdfasdf'\nuser_id = 1\ndt = '2019-09-03'\nurl = f'http://you-are-one.com/?token={token}&user_id={user_id}&dt={dt}'\nurl\nOut[]：\n'http://you-are-one.com/?token=asdfasdfasdfasdf&user_id=1&dt=2019-09-03'\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python字符串格式化",
        "date": "2019-09-03 14:29:12",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-ge-shi-hua"
    },
    {
      "content": "# 定义\n单/双引号只能定义单行字符串，不能定义多行字符串\n三引号可以定义多行字符串\n# 转义\n转义符号用“\\”\n转义符号还可以使用前缀关键字r，它代表的意思是：后面的字符串是raw string\n特别是写正则的时候需要加上r前缀\nu前缀代表unicode字符串\nb前缀代表bytes\n# 下标操作\n字符串可以使用下标访问\n**字符串是不可变的**\n**字符串是迭代器，是可迭代对象**\nlist()可以将字符串转化为列表\n```\nIn[]：\ns = 'python'\nlist(s)\nOut[]：\n['p', 'y', 't', 'h', 'o', 'n']\n```\ncount()可以计算字符串中某个字符出现的次数\n```\nIn[]：\ns = '霍霍霍霍霍元甲'\ns.count('霍')\nOut[]：\n5\n```\nindex()可以搜索字符串中某个字符的位置\n```\nIn[]：\ns = '霍霍霍霍霍元甲'\ns.index('霍')\nOut[]：\n0\n```\n# 字符串的操作\n## join\njoin是字符串的方法，参数是可迭代对象，接受者是分隔符\n```\nIn[]：\nl = ['i','use','python']\n','.join(l)\nOut[]：\n'i,use,python'\n```\n## 字符串分割\n### str.split\n```\nIn[]：\nhelp(str.split)\nOut[]：\nHelp on method_descriptor:\nsplit(self, /, sep=None, maxsplit=-1)\n    Return a list of the words in the string, using sep as the delimiter string.\n    sep\n      The delimiter according which to split the string.\n      None (the default value) means split according to any whitespace,\n      and discard empty strings from the result.\n    maxsplit\n      Maximum number of splits to do.\n      -1 (the default value) means no limit.\n```\nstr.split()，默认使用空格分割，当遇到多个空格，默认会当作一个空格处理\n```\nIn[]：\ns = \"life        is short\"\ns.split()\nOut[]：\n['life', 'is', 'short']\n```\n但是，当指定了一个空格为分隔符，一个空格就当作一个空格处理\n```\nIn[]：\ns = \"life        is short\"\ns.split(' ')\nOut[]：\n['life', '', '', '', '', '', '', '', 'is', 'short']\n```\n参数maxsplit表示从左到右分割多少次，默认为-1，表示分割所有分隔符\n```\nIn[]：\ns = \"life        is short\"\ns.split(maxsplit=1)\nOut[]：\n['life', 'is short']\n```\n分隔符可以是任意字符串\n```\nIn[]：\ns = \"life        is short\"\ns.split('is')\nOut[]：\n['life        ', ' short']\n```\n### str.rsplit\n```\nIn[]：\nhelp(str.rsplit)\nOut[]：\nHelp on method_descriptor:\nrsplit(self, /, sep=None, maxsplit=-1)\n    Return a list of the words in the string, using sep as the delimiter string.\n      sep\n        The delimiter according which to split the string.\n        None (the default value) means split according to any whitespace,\n        and discard empty strings from the result.\n      maxsplit\n        Maximum number of splits to do.\n        -1 (the default value) means no limit.\n    Splits are done starting at the end of the string and working to the front.\n```\nrsplit就是从右往左分割的\n### str.splitlines\n```\nIn[]：\nhelp(str.splitlines)\nOut[]：\nHelp on method_descriptor:\nsplitlines(self, /, keepends=False)\n    Return a list of the lines in the string, breaking at line boundaries.\n    Line breaks are not included in the resulting list unless keepends is given and\n    true.\n```\nsplitlines()方法比较简单，但是很实用，就是在读文件的时候，可以快速分割行\n按行分割，并且返回值不带换行符\n```\nIn[]：\ns = '''life\nis\nshort\n'''\ns.splitlines()\nOut[]：\n['life', 'is', 'short']\n```\n按行分割，并且返回值带换行符\n```\nIn[]：\ns = '''life\nis\nshort\n'''\ns.splitlines(True)\nOut[]：\n['life\\n', 'is\\n', 'short\\n']\n```\n### str.partition\n```\nIn[]：\nhelp(str.partition)\nOut[]：\nHelp on method_descriptor:\npartition(self, sep, /)\n    Partition the string into three parts using the given separator.\n    This will search for the separator in the string.  If the separator is found,\n    returns a 3-tuple containing the part before the separator, the separator\n    itself, and the part after it.\n    If the separator is not found, returns a 3-tuple containing the original string\n    and two empty strings.\n```\npartition其实就是split的指定分隔符，maxsplit=1的特殊版本\n```\nIn[]：\ns = 'life is short'\ns.partition(' ')\nOut[]：\n('life', ' ', 'is short')\n```\n* 总是返回一个三元组（由三个元素构成的）\n* 按照传入的分隔符分割一次\n* 返回结果是head,sep,tail\nrpartition是partition从右往左的版本\n通常在对配置文件做操作的时候，我们会用partition\n## 大小写转换\n### str.upper & str.lower\n```\nIn[]：\ns = 'tEst'\ns.upper()\nOut[]：\n'TEST'\n```\n```\nIn[]：\ns = 'tEst'\ns.lower()\nOut[]：\n'test'\n```\nupper和lower两个方法都是**原地不修改，有返回值**\n### str.swapcase\n大小写互换，**原地不修改，有返回值**\n```\nIn[]：\ns = 'tEst'\ns.swapcase()\nOut[]：\n'TeST'\n```\n## 排版\n### str.title\n每个单词首字母大写，**原地不修改，有返回值**\n```\nIn[]：\ns = 'tEst hello'\ns.title()\nOut[]：\n'Test Hello'\n```\n### str.capitalize\n一句话的首字母大写，**原地不修改，有返回值**\n```\nIn[]：\ns = 'life is short'\ns.capitalize()\nOut[]：\n'Life is short'\n```\n### str.center\n在指定支付长度中居中，**原地不修改，有返回值**\n```\nIn[]：\ns = 'test'\ns.center(100)\nOut[]：\n'                                                test                                                '\n```\n```\nIn[]：\ns = 'test'\ns.center(100,'-')\nOut[]：\n'------------------------------------------------test------------------------------------------------'\n```\n### str.zfill\n用0补足，**原地不修改，有返回值**\n```\nIn[]：\ns = 'tEst'\ns.zfill(50)\nOut[]：\n'0000000000000000000000000000000000000000000000tEst'\n```\n## 修改\n### str.replace\nreplace返回一个新的字符串，原地不修改，有返回值\n```\nIn[]：\ns = 'life is short'\ns.replace('short','long')\nOut[]：\n'life is long'\n```\n### str.strip\n去除字符串前后的空格\n```\nIn[]：\ns = '   life is short   '\ns.strip()\nOut[]：\n'life is short'\n```\n其实strip去除的是空白字符，不只是空格\n```\nIn[]：\ns = '\\t\\n\\r life is short '\ns.strip()\nOut[]：\n'life is short'\n```\n而且strip可以去除指定的字符，但是仅限于前后\n```\nIn[]：\ns = '#-#   life is short  #-#'\ns.strip('#')\nOut[]：\n'-#   life is short  #-'\n```\n还可以去除多个字符，按照先后顺序\n```\nIn[]：\ns = '###  H is happy H #'\ns.strip('#H ')\nOut[]：\n'is happy'\n```\n### str.lstrip\n只移除左边的\n```\nIn[]：\ns = '###life is short'\ns.lstrip('#')\nOut[]：\n'life is short'\n```\n只移除右边的\n```\nIn[]：\ns = 'life is short###'\ns.rstrip('#')\nOut[]：\n'life is short'\n```\n### str.ljust\n用来填充字符，原字符串在左边\n```\nIn[]：\ns = 'life is short'\ns.ljust(50)\nOut[]：\n'life is short                                     '\n```\n可以指定填充字符\n```\nIn[]：\ns = 'life is short'\ns.ljust(50,'$')\nOut[]：\n'life is short$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'\n```\n### str.rjust\n用来填充字符，原字符串在右边\n```\nIn[]：\ns = 'life is short'\ns.rjust(50,'$')\nOut[]：\n'$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$life is short'\n```\n## 查找\n### str.find\n从左往右查找，找到第一个子串，返回子串首字母的索引\n```\nIn[]：\ns = 'life is short'\ns.find('f')\nOut[]：\n2\n```\n当子串不存在的时候返回-1\n```\nIn[]：\ns = 'life is short'\ns.find('F')\nOut[]：\n-1\n```\nstart参数和stop参数是开始查找的索引和结束查找的索引，左闭右开，不包含end参数，end=-1代表的就是最后\n### str.rfind\nfind从右往左的版本\n```\nIn[]：\ns = 'life is funny'\ns.rfind('f')\nOut[]：\n8\n```\n### str.index\nindex查找，子串不存在时，抛出ValueError\nfind查找时，子串不存在，返回-1\n这是index和find的唯一区别\n### str.rindex\nrindex是index从右往左的版本\n### str.count\n计算参数在字符串中的个数，当count计算的值不存在的时候返回0\ncount同样也是有start参数和end参数的\n```\nIn[]：\ns = '###life is funny###'\ns.count('#')\nOut[]：\n6\n```\n### str.startswith\n判断字符串是否以某个前缀开始，返回结果是bool值\nstart参数，end参数和find一样\n```\nIn[]：\ns = '###life is funny###'\ns.startswith('#')\nOut[]：\nTrue\n```\n### str.endswith\nendswith判断字符串是否以某个后缀结束，返回bool\nstart参数，end参数和find一样\n```\nIn[]：\ns = '###life is funny###'\ns.endswith('#')\nOut[]：\nTrue\n```\n### is*\nis\\*的意思就是，字符串的方法里有一串以is开头的方法，代表的意思就是“是否是xxx”\nisalnum判断是否是只含有字母\n```\nIn[]：\ns = 'qwer'\ns.isalnum()\nOut[]：\nTrue\n```\nisdecimal判断是否是数字\n```\nIn[]：\ns = '12345'\ns.isdecimal()\nOut[]：\nTrue\n```\nisidentifier判断是否是字母或者下划线开头，且包含字母数字和下划线\n```\nIn[]：\ns = '_is1'\ns.isidentifier()\nOut[]：\nTrue\n```\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python字符串及其常用操作",
        "date": "2019-08-29 15:04:43",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-ji-qi-chang-yong-cao-zuo"
    },
    {
      "content": "元组：tuple\ntuple和list非常相似，但是tuple一旦初始化就不能修改\ntuple获取元素的方法与list一样，通过索引获取\n定义一个空的tuple：\n```\nt = ()\n```\n但是要定义一个只有一个元素的tuple，必须加一个逗号，来消除歧义\n```\nt = (1,)\n```\n“可变的”tuple\n```\nIn[]：\nt = ('a','b',['python','java'])\nprint(t)\nt[2][1] = 'php'\nprint(t)\nOut[]：\n('a', 'b', ['python', 'java'])\n('a', 'b', ['python', 'php'])\n```\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python元组及其常用操作",
        "date": "2019-08-29 13:57:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-yuan-zu-ji-qi-chang-yong-cao-zuo"
    },
    {
      "content": "# 概念\n在其他语言里，会叫这种数据类型为数组，array，在python里，我们叫列表，list\n列表是一种数据结构\n列表是一个序列，用于顺序的存储数据。\n序列是python中最基本的数据结构。\n序列中的每个元素都分配一个数字：索引\n```\nl = list()\nl = []\nl = [1,2,3]\nl = list(range(1,10))\n```\n通常在定义列表的时候用\\[]，在转化可迭代对象为列表的时候用list函数\n# 访问列表\n定义一个1-9的列表\n```\nl = list(range(1,10))\n```\n通过下标访问，下标从0开始\n```\nl[0]\n```\n当下标超出范围时，会抛出IndexError\n```\nl[100]\n```\n负数索引从右边开始，并且索引从-1开始\n## list.index\n也可以通过help函数查看所有方法的函数签名，也就是函数说明\n```\nIn[]：help(list.index)\nOut[]：\nHelp on method_descriptor:\nindex(self, value, start=0, stop=9223372036854775807, /)\n    Return first index of value.\n    Raises ValueError if the value is not present.\n```\n这里函数签名中，stop有个默认值，也就是到列表哪一个位置结束，这也是它的最大值了，超出了可能就内存溢出。\n\"list.index\"方法返回查找到的第一个索引\n```\nl = list(range(1,10))\nl.index(4)\nnew_l = [1,2,3,2,4,3,5]\nnew_l.index(2)\nnew_l.index(2,2,3)\nnew_l.index(2,-1)\nnew_l.index(2,-4,-1)\n```\nlist.index的start和end参数可以为负数，但是在查找过程中还是从左到右的顺序\n当查找不到元素时，抛出错误ValueError。\n### list.index函数解读\n实现list.index函数：\n```\ndef index(lst,val,start=0,end=-1):\n    i = start\n    for x in lst[start:end]:\n        if x == val:\n            return i\n        i += 1\n    raise ValueError()\n```\n## list.count\n查看一下list.count的函数签名\n```\nIn[]：help(list.count)\nOut[]：\nHelp on method_descriptor:\ncount(self, value, /)\n    Return number of occurrences of value.\n```\nlist.count，统计你要查询的字符在列表里出现的次数\n```\nnew_l = [1,2,3,2,4,3,5]\nnew_l.count(5)\nnew_l.count(10)\n```\n### list.count函数解读\n实现list.count函数：\n```\ndef count(lst,value):\n    c = 0\n    for x in lst:\n        if x == value:\n            c += 1\n    return c\n```\n## 总结\n* list通过索引访问元素\n* index方法根据值返回第一个索引\n* count方法返回元素在列表里的个数\n\nindex和count的时间复杂度是O(n)\n# 列表修改\n通过索引的方式进行赋值即可\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l[2] = 5\nprint(new_l)\nOut[]：\n[1, 2, 5, 2, 4, 3, 5]\n```\n超出范围还是会抛出IndexError\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l[10] = 10\nOut[]：\nIndexError                                Traceback (most recent call last)\n<ipython-input-3-daf879895697> in <module>\n      1 new_l = [1,2,3,2,4,3,5]\n----> 2 new_l[10] = 10\nIndexError: list assignment index out of range\n```\n# 列表增加\n## list.append\n先用help函数看下它的函数签名\n```\nIn[]：\nhelp(list.append)\nOut[]：\nHelp on method_descriptor:\nappend(self, object, /)\n    Append object to the end of the list.\n```\nappend**原地修改list，返回值是None**,直接在最后加一位，我们称之为追加\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.append(99)\nprint(new_l)\nOut[]：\n[1, 2, 3, 2, 4, 3, 5, 99]\n```\n## list.insert\n在第i个元素前插入e\n```\nIn[]：\nhelp(list.insert)\nOut[]：\nHelp on method_descriptor:\ninsert(self, index, object, /)\n    Insert object before index.\n```\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(1,99)\nprint(new_l)\nOut[]：\n[1, 99, 2, 3, 2, 4, 3, 5]\n```\n**当越界的时候，自动往左或往右插入该值，这点非常重要，它并不会报错**\n```\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(100,99)\nprint(new_l)\nOut[]：\n[1, 2, 3, 2, 4, 3, 5, 99]\nIn[]：\nnew_l = [1,2,3,2,4,3,5]\nnew_l.insert(-100,99)\nprint(new_l)\nOut[]：\n[99, 1, 2, 3, 2, 4, 3, 5]\n```\nappend和insert的效率：\n* append的时间复杂度是O(1)，常数时间，效率和数据的规模无关\n* insert的时间复杂度是O(n)，线性时间，效率和数据规模线性相关\n\n**尽量使用append**\n## list.extend\nextend将任意可迭代对象追加到数据的末尾，**原地修改，返回None**\n```\nIn[]：\nhelp(list.extend)\nOut[]：\nHelp on method_descriptor:\nextend(self, iterable, /)\n    Extend list by appending elements from the iterable.\n```\n值得注意的是，extend是把可迭代对象里的每一个值循环append到list里去，而不是像append，直接把一整个对象追加到列表的队尾\n* append操作单个元素\n* extend操作可迭代对象\n\n对比栗子：\n```\nIn[]：\nnew_l = [0,1,2]\nnew_l.append([1,2,3])\nprint(new_l)\nOut[]：\n[0, 1, 2, [1, 2, 3]]\nIn[]：\nnew_l = [0,1,2]\nnew_l.extend([1,2,3])\nprint(new_l)\nOut[]：\n[0, 1, 2, 1, 2, 3]\n```\n**list.extend经常用在两个列表的相加上**\n## list + list\n两个列表的相加还可以直接用加号\n```\nIn[]：\nl = [0,1,2,3,4]\na = l + ['a','b','c']\nprint('a:',a)\nprint('l:',l)\nOut[]：\na: [0, 1, 2, 3, 4, 'a', 'b', 'c']\nl: [0, 1, 2, 3, 4]\n```\n**这种方法有返回值，但是不修改list本身，返回一个新的list**，这种操作叫list的连接操作\n# 列表删除\n## list.remove\n```\nIn[]：\nhelp(list.remove)\nOut[]：\nHelp on method_descriptor:\nremove(self, value, /)\n    Remove first occurrence of value.\n    Raises ValueError if the value is not present.\n```\n删除第一个匹配的元素\n```\nIn[]：\nl = [1,2,3,2,3,4,3,5,3,4]\nl.remove(2)\nprint(l)\nOut[]：\n[1, 3, 2, 3, 4, 3, 5, 3, 4]\n```\n**原地修改，返回None，根绝值删除元素**\n当值不存在时，抛出ValueError\n```\nIn[]：\nl = [1,2,3,2,3,4,3,5,3,4]\nl.remove(10)\nOut[]：\nValueError                                Traceback (most recent call last)\n<ipython-input-5-13fc432ba077> in <module>\n      1 l = [1,2,3,2,3,4,3,5,3,4]\n----> 2 l.remove(10)\nValueError: list.remove(x): x not in list\n```\n## list.pop\n```\nIn[]：\nhelp(list.pop)\nOut[]：\nHelp on method_descriptor:\npop(self, index=-1, /)\n    Remove and return item at index (default last).\n    Raises IndexError if list is empty or index is out of range.\n```\n不传入参数，则默认返回并删除最后一个值\n传入index参数，返回并删除index所在的值\n```\nIn[]：\nl = [3,2,4,3,5,3,4]\nl.pop(3)\nprint(l)\nOut[]：\n3\n[3, 2, 4, 5, 3, 4]\n```\n**注意：这个传入的参数是index，不是元素的值**\n当索引不存在时，抛出IndexError\n```\nIn[]：\nl = [3,2,4,3,5,3,4]\nl.pop(100)\nOut[]：\nIndexError                                Traceback (most recent call last)\n<ipython-input-10-85aba9b20ee8> in <module>\n      1 l = [3,2,4,3,5,3,4]\n----> 2 l.pop(100)\nIndexError: pop index out of range\n```\n这里需要注意几点：\n* pop不传递index参数，时间复杂度是O(1)\n* pop传递index参数，时间复杂度是O(n)\n* pop根据索引删除元素，并且返回删除的元素\n* remove根据值删除元素，返回None\n\n## list.clear\n```\nIn[]：\nhelp(list.clear)\nOut[]：\nHelp on method_descriptor:\nclear(self, /)\n    Remove all items from list.\n```\n删除所有元素\n```\nIn[]：\nl = [3,2,3,5,3,4]\nl.clear()\nprint(l)\nOut[]：\n[]\n```\n使用clear后，列表对象还存在，只是里面的值都被清空了\n# 其它操作\n## 求list的长度\nlen(l)\n```\nIn[]：\nl = [3,2,3,5,3,4]\nlen(l)\nOut[]：\n6\n```\n## 反转列表\nl.reverse()\n```\nIn[]：\nl = [0,1,2,3,4,5,6]\nl.reverse()\nprint(l)\nOut[]：\n[6, 5, 4, 3, 2, 1, 0]\n```\n## 列表排序\nl.sort()\n```\nIn[]：\nl = [2,5,3,6,1,4,8,9]\nl.sort()\nprint(l)\nOut[]：\n[1, 2, 3, 4, 5, 6, 8, 9]\n```\n**原地修改，返回None**\n**逆序排序，l.sort(reverse=True)**\n```\nIn[]：\nl = [2,5,3,6,1,4,8,9]\nl.sort(reverse=True)\nprint(l)\nOut[]：\n[9, 8, 6, 5, 4, 3, 2, 1]\n```\n## 列表拷贝\n### 引用传递\n```\nIn[]：\na = [1,2,3]\nb = a\nprint(b)\nb[1] = 99\nprint(b)\nprint(a)\nOut[]：\n[1, 2, 3]\n[1, 99, 3]\n[1, 99, 3]\n```\n### 浅复制（浅拷贝）\n```\nIn[]：\nl = [1,2,3,4,5]\nl2 = l.copy()\nl2[0] = 'a'\nprint(l)\nprint(l2)\nOut[]：\n[1, 2, 3, 4, 5]\n['a', 2, 3, 4, 5]\n```\n如果列表存在嵌套列表\n```\nIn[]：\nl = [1,[1,2,3],4]\nl2 = l.copy()\nl2[1][1] = 'a'\nprint(l2)\nprint(l)\nOut[]：\n[1, [1, 'a', 3], 4]\n[1, [1, 'a', 3], 4]\n```\n### 深复制（深拷贝）\n使用深拷贝需要引入copy模块，使用deepcopy\n```\nIn[]：\nfrom copy import deepcopy\nl = [1, [1, 'a', 3], 4]\nl2 = deepcopy(l)\nl2[1][1] = 'b'\nprint(l2)\nprint(l)\nOut[]：\n[1, [1, 'b', 3], 4]\n[1, [1, 'a', 3], 4]\n```\n\n\n\n\n\n",
      "data": {
        "title": "Python列表及其常用操作",
        "date": "2019-08-28 14:07:15",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-nei-zhi-shu-ju-jie-gou"
    },
    {
      "content": "# 常量变量 & 类型系统\n## 常量变量\n常量：一旦赋值，就不能改变它的值。也就是说不能对它进行重新赋值。\n变量：是一个名字，在赋值符号的左边，这个名字可以指代赋值符号右边的内容。\n注意：Python不存在常量。因为Python一切皆对象，Python赋值即定义。\n## 类型系统\npython是门强类型的动态语言，但它同时又是一门解释性语言。\n那么作为强类型语言，python就有自己的类型系统，python的类型系统分为基本类型和内置数据结构。\n基本类型分为：\n* int\n* float\n* bool\n* None\n\nstr、list、dict等在官方文档中查到，隶属于：built-in structure。\n内置数据结构分为：\n* str\n* list\n* tuple\n* set\n* dict\n* bytes\n* bytearray\n\n动态语言指一个变量的类型可以被多次修改、赋值。\n而在java、c#这种静态语言中，一旦定义了一个变量\n```\nstring strA = 'a'\n```\n就无法改变它的类型了，只能改变值。\n# 基本数据类型\n## 整型和浮点型\n在python2里区分整型和长整型，python3里不区分，只有整型。\n对于int来说，不存在溢出。\n但float会溢出，会损失精度，这也就是我们常说的精度失效。\n举个简单的栗子：\n```\nIn[1]：3.3 * 6\nOut[1]：19.799999999999997\n```\n### 为什么会有精度失效\n因为计算机都是用二进制表示的，那么势必会存在0和1之间的数字没法表示。\n### 二进制小数转十进制小数\n采用方法：按权展开求和法\n举个栗子：将101.111(2)这个二进制小数转换成十进制数。\n计算：1*(2^2)+0*(2^1)+1*(2^0)+1*(2^(-1))+1*(2^(-2))+1*(2^(-3))=5.875\n### 十进制小数转二进制小数\n十进制数的整数位是二进制数的整数位，十进制数的小数位是二进制数的小数位\n假如有小数111.4(10)，进行计算\n小数位采用“乘二取整法”（顺序排列），取整就是取整数位上的数字\n| 乘二 |  取整 |\n| - | - |\n| 0.4\\*2=0.8 | 0 |\n| 0.8\\*2=1.6 | 1 |\n| 0.6\\*2=1.2 | 1 |\n| 0.2\\*2=0.4 | 0 |\n| 0.4\\*2=0.8 | 0 |\n| 0.8\\*2=1.6 | 1 |\n| 0.6\\*2=1.2 | 1 |\n| 0.2\\*2=0.4 | 0 |\n经过计算发现出现了循环，0.01100110...(循环0110)\n整数位采用“除二取余法”（逆序排列）\n| 除二 | 商 | 余数 |\n| - | - | - |\n| 111/2 | 55 | 1 |\n| 55/2 | 27 | 1 |\n| 27/2 | 13 | 1 |\n| 13/2 | 6 | 1 |\n| 6/2 | 3 | 0 |\n| 3/2 | 1 | 1 |\n| 1/2 | 0 | 1 |\n所以整数位是1101111\n最终结果是整数位和小数位合并1101111.01100110......\n### 代码\n从代码角度出发，如何规避这类情况？那就要用到经常提到的一个概念：“精确到小数点后面多少位”\n```\nfrom decimal import Decimal\nfrom decimal import getcontext\ngetcontext().prec = 8\nIn[]：Decimal(3.3) * Decimal(6)\nOut[]：Decimal('19.800000')\n```\n## None\nNone就是一个类型，在js里面有undefined和null，但是python只有一个None。\nNone既不是空字符串，也不是未定义\nNone在判断语句中位False，但None不等于False\n```\nIn[]：None == False\nOut[]：False\n```\n## Bool\nBool就是True or False。\n## 总结\n基本数据类型一共有4种，int、float、bool、None\n# 运算符\n## 算数运算符\n* \\+\n* \\-\n* \\*\n* \\/\n* \\//\n* \\**\n* \\%\n\n以上就是python运算符，但是要注意：只能对int和float做运算。\n特别说明：\n/运算符在python3是自然除，python2是整除\n## 比较运算符\n* \\>\n* \\<\n* \\=\n* \\!=\n* \\>=\n* \\<=\n\n所有比较运算符的返回值都是bool类型\n## 逻辑运算符\n* and\n* or\n* not\n\n逻辑运算符的两边必须是True或False\n注意：逻辑运算符的短路\nor运算，只要执行到第一个位true的时候之后就不执行了。\n## 成员运算符\n* in\n* not in\n\n## 身份运算符\n* is\n* is not\n\n## 位运算符\n* \\<<\n* \\>>\n* &\n* |\n* ^ 异或\n\n位运算符用在哪里呢？\n### 判断奇偶数\n我们可以利用&运算符的特性来判断二进制数最后一位是0还是1。\n用if((a&1) == 0)代替if(a%2 == 0)来判断a是不是偶数。\n### 交换两个数\n先了解一下^的几个特性\n* a^a = 0\n* a^0 = a\n* (a^b)^c = a^(b^c)\n\n交换两个数的方法为：\n```\na ^= b\nb ^= a\na ^= b\n```\n从数学角度分析一下：\na = a ^ b\nb = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a\na = a ^ b = (a ^ b) ^ b = (a ^ a) ^ b = b ^ 0 = b\n## 赋值运算符\n* i += 3\n* i \\*= 3\n\n所有的算术运算符都可以和赋值运算符一起使用。\n# 表达式 & 程序结构\n## 表达式 & 语句\n表达式：常量/变量和运算符一起构成，表达式有返回值\n语句：关键字和表达式一起构成，语句没有返回值\n## 顺序结构\n就是代码从上到下，一行一行执行\n## 分支结构\n### 单分支\n单分支只有一个操作，条件成立去做操作，然后结束，否则直接结束。\n```\na = 5\nif a < 10:\n    print('a less than 10')\nprint(a)\n```\n### 双分支\n双分支就是当条件不成立的时候还多了一个操作，方便做逻辑处理。\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelse:\n    print('a is not less than 10')\nprint(a)\n```\n双分支结构永远只有一个条件会被执行\n### 嵌套\n嵌套的意思就是，在if里面还可以有if\n通过结构嵌套实现多分支\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelse:\n    if a < 20:\n        print('10 <= a < 20')\n    else:\n        print('a is not less than 10')\nprint(a)\n```\n### 关键字elif\n```\na = 5\nif a < 10:\n    print('a less than 10')\nelif a < 20:\n    print('10 <= a < 20')\nelse:\n    print('a is not less than 10')\nprint(a)\n```\n对于分支结构来说，总结一下就是：\n1. 分支结构永远只有1个或者0个分支会被执行\n2. 分支结构中所有条件是互斥的\n3. 条件只能是bool类型或者可以隐式转换为bool类型\n## 循环结构\n### while\nwhile循环需要一个条件支撑，如果条件为True，循环将继续。\n### for in\npython的for循环和其他语言不一样，在for关键字里实现了一个迭代协议，通过迭代协议完成了对可迭代对象的循环。\n#### 提前终止\n当在for循环体内，遇到break关键字的时候，将会结束本层循环，注意不是本次，是本层\n如果是两个for循环,那么就会退出本层循环，进入上层循环的下一次循环中\n```\nfor i in range(3):\n    for j in range(5):\n        print('j:' + str(j))\n        if j % 2 == 0:\n            print('i:',i,'j:',j)\n            break\n```\n#### 跳过\ncontinue是跳过本次循环，继续下一次循环，**注意这里是继续同一层的下一次循环**\n```\nfor i in range(0,3):    \n    if i % 2 != 0:\n        print(i)\n        continue\n```\n### else子句\n在python中，for循环还有一个其他语言没有的关键字，else\n这个else不是if的else，而是for的else。只有当for循环的主体循环全部结束后，才会去执行else语句。\n举个栗子：\n```\nIn[0]:\nfor i in range(10):\n    pass\nelse:\n    print('ok')\nOut[0]:ok\n```\n如果循环体被break了呢？\n```\nIn[0]:\nfor i in range(10):\n    break\nelse:\n    print('ok')\nOut[0]:\n```\n如果是continue呢？\n```\nIn[0]:\nfor i in range(10):\n    continue\nelse:\n    print('ok')\nOut[0]:ok\n```\n结论：**当循环没有提前退出时，会执行else子句**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Python基本语法",
        "date": "2019-08-27 13:51:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ji-ben-yu-fa"
    },
    {
      "content": "# Git配置\nGit安装完成后需要配置个人的用户名称和邮件地址\n```\ngit config --global user.name \"yanghang\"\ngit config --global user.email yanghang0214@qq.com\n```\n查看配置信息\n```\ngit config --list\n```\n# Git创建仓库\n初始化Git仓库\n```\ngit init\n```\n将文件添加到缓存，例如添加两个文件：\n```\ngit add <file1> <file2> \n```\n或者添加所有文件，可以使用\n```\ngit add .\n```\n查看文件是否添加成功：\n```\ngit status\ngit status -s\n```\n将缓存区内容添加到仓库中：\n```\ngit commit -m '本次提交的说明'\n```\n查看文件修改了哪些内容：\n```\ngit diff readme.txt \n```\n查看git提交修改的日志：\n```\ngit log\n```\nGit版本回退，在Git中用HEAD表示当前版本，上个版本是HEAD\\^,上上个版本是HEAD\\^^，往上100个写成HEAD\\~100：\n```\ngit reset --hard HEAD^\n```\n要重返未来需要查看命令历史\n```\ngit reflog\n```\n# Git添加远程仓库\n**创建SSH Key**\n使用自己的邮件地址，一路回车使用默认值。完成后可以在**用户主目录**里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，id_rsa是私钥，id_rsa.pub是公钥。\n```\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n**在GitHub添加key**\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴**id_rsa.pub**文件的内容，点“Add Key”，你就应该看到已经添加的Key。\n**关联远程仓库**\n远程库的名字就是origin，这是Git默认的叫法，也可以改成别的\n```\ngit remote add origin git@github.com:yh0214/grideasourcecode.git\n```\n**本地推送至远程库**\n首先添加内容到缓存：git add <file1>，然后由缓存添加内容到仓库：git commit -m '本次提交的说明'；使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，可以使用命令git push origin master推送最新修改\n```\ngit push -u origin master\ngit push origin master\n```\n**从远程库克隆至本地**\n```\ngit clone git@github.com:yh0214/grideasourcecode.git\n```\n**删除github上文件**\n```\ngit rm -r --cached 文件夹名称\ngit commit -m 'delete 文件夹名称 dir'\ngit push -u origin master\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "Git",
        "date": "2019-08-27 08:31:42",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "Python",
      "slug": "b-HvOq5Zt",
      "used": false
    }
  ],
  "menus": []
}