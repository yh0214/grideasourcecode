{
  "posts": [
    {
      "content": "面向对象（OOP）是一种编程范式\r\n范式可以认为是一组方法论\r\n编程范式就是一组如何组织代码的方法论\r\nOOP的世界观：\r\n世界是由对象组成的\r\n对象具有运动规律和内部状态\r\n对象之间可以相互作用\r\nOOP的特征：\r\n封装\r\n继承\r\n多态\r\n类的定义\r\n```\r\nclass Door:\r\n    def __init__(self,number,status):\r\n        self.number = number\r\n        self.status = status\r\n\r\ndoor = Door(10001,'closed')\r\n```\r\n```\r\nIn[]：door.number\r\nOut[]：10001\r\n```\r\n看一下self\r\n```\r\nclass D:\r\n    def __init__(self):\r\n        print(id(self))\r\n```\r\n```\r\nIn[]：d = D()\r\nOut[]：101570264\r\n```\r\n```\r\nIn[]：id(d)\r\nOut[]：101570264\r\n```\r\n这个self就是d，而且是先有的self\r\n__init__函数并不是来生成对象的，只是来初始化类\r\n类中定义方法及调用\r\n```\r\nclass Door:\r\n    def __init__(self,number,status):\r\n        self.number = number\r\n        self.status = status\r\n    \r\n    def open(self):\r\n        self.status = \"opening\"\r\n\r\n    def close(self):\r\n        self.status = \"closed\"\r\n```\r\n```\r\ndoor = Door(10001,'closed')\r\n```\r\n```\r\nIn[]：door.status\r\nOut[]：'closed'\r\n```\r\n```\r\ndoor.open()\r\n```\r\n```\r\nIn[]：door.status\r\nOut[]：'opening'\r\n```\r\n```\r\ndoor.close()\r\n```\r\n```\r\nIn[]：door.status\r\nOut[]：'closed'\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "面向对象基础",
        "date": "2019-10-16 09:07:30",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mian-xiang-dui-xiang-ji-chu"
    },
    {
      "content": "首先看一下装饰器的副作用\r\n```\r\nimport datetime\r\ndef logger(fn):\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end-start))\r\n        return ret\r\n    return wrap\r\n```\r\n```\r\nimport time\r\n@logger\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n使用装饰器定义一个sleep函数，查看它的'__name__'\r\n```\r\nIn[]:sleep.__name__\r\nOut[]:'wrap'\r\n```\r\n是wrap而不是sleep，这就是使用了装饰器后的副作用\r\n如何解决？\r\n首先可以使用赋值\r\n```\r\nimport datetime\r\ndef logger(fn):\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end-start))\r\n        return ret\r\n    wrap.__name__ = fn.__name__\r\n    wrap.__doc__ = fn.__doc__\r\n    return wrap\r\n```\r\n```\r\nimport time\r\n@logger\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]:sleep.__name__\r\nOut[]:'sleep'\r\n```\r\n其次也可以写一个函数\r\n```\r\ndef copy_properties(src,dst):\r\n    dst.__name__ = src.__name__\r\n    dst.__doc__ = src.__doc__\r\n```\r\n```\r\nimport datetime\r\n\r\ndef logger(fn):\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end-start))\r\n        return ret\r\n    copy_properties(fn,wrap)\r\n    return wrap\r\n```\r\n柯里化\r\n```\r\ndef copy_properties(src):\r\n    def _copy(dst):\r\n        dst.__name__ = src.__name__\r\n        dst.__doc__ = src.__doc__\r\n        return dst\r\n    return _copy\r\n```\r\ncopy_properties返回的是一个装饰器，可以这么来写\r\n```\r\nimport datetime\r\n\r\ndef logger(fn):\r\n    @copy_properties(fn)\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end-start))\r\n        return ret\r\n    return wrap\r\n```\r\n再看下sleep.__name__\r\n```\r\nIn[]:sleep.__name__\r\nOut[]:'sleep'\r\n```\r\nfunctools\r\n```\r\nhelp(functools.wraps)\r\nHelp on function wraps in module functools:\r\n\r\nwraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\r\n    Decorator factory to apply update_wrapper() to a wrapper function\r\n    \r\n    Returns a decorator that invokes update_wrapper() with the decorated\r\n    function as the wrapper argument and the arguments to wraps() as the\r\n    remaining arguments. Default arguments are as for update_wrapper().\r\n    This is a convenience function to simplify applying partial() to\r\n    update_wrapper().\r\n```\r\n看看如何使用\r\n```\r\nimport datetime\r\nimport functools\r\ndef logger(fn):\r\n    @functools.wraps(fn)\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end - start))\r\n        return ret\r\n    return wrap\r\n```\r\n```\r\nimport time\r\n@logger\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]:sleep(3)\r\nOut[]:sleep called took 0:00:03.000353\r\n```\r\n这个就是copy_properties的由来\r\n柯里化其实是一个数学的概念，目的是让多个参数变成单个参数\r\n带参数的装饰器\r\n假如需要记录大于某个时间的操作，并且可以对这个时间做控制，通过参数传递进来\r\n```\r\nimport functools\r\nimport datetime\r\ndef logger(s):\r\n    def _logger(fn):\r\n        @functools.wraps(fn)\r\n        def wrap(*args,**kwargs):\r\n            start = datetime.datetime.now()\r\n            ret = fn(*args,**kwargs)\r\n            end = datetime.datetime.now()\r\n            if (end - start).total_seconds() > s:\r\n                print('call {} took {}'.format(fn.__name__,end - start))\r\n            return ret\r\n        return wrap\r\n    return _logger\r\n```\r\n(end - start).total_seconds()将时间格式的时间差转为数字格式\r\n```\r\nimport time\r\n@logger(1)\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n执行时间大于1s的操作进行记录\r\n```\r\nIn[]:sleep(2)\r\nOut[]:call sleep took 0:00:02\r\n```\r\n```\r\nIn[]:sleep(1)\r\nOut[]:\r\n```\r\n```\r\nIn[]:sleep(3)\r\nOut[]:call sleep took 0:00:03\r\n```\r\nsleep(2)和sleep(3)执行完后进行了记录，sleep(1)执行完没有进行记录\r\n@logger(1)拆开就是logger(1)(sleep)\r\n带参数的装饰器：一个函数，返回一个不带参数的装饰器\r\n多参数\r\n```\r\nimport functools\r\nimport datetime\r\ndef logger(s,p = lambda name,t : print('call {} took {} '.format(name,t))):\r\n    def _logger(fn):\r\n        @functools.wraps(fn)\r\n        def wrap(*args,**kwargs):\r\n            start = datetime.datetime.now()\r\n            ret = fn(*args,**kwargs)\r\n            end = datetime.datetime.now()\r\n            if (end - start).total_seconds() > s:\r\n                p(fn.__name__,end - start)\r\n            return ret\r\n        return wrap\r\n    return _logger\r\n```\r\n```\r\nimport time\r\n@logger(1)\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]：sleep(2)\r\nOut[]：call sleep took 0:00:02 \r\n```\r\n```\r\nimport time\r\n@logger(1,p = lambda name,t : print('hahahaha'))\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]：sleep(2)\r\nOut[]：hahahaha\r\n```\r\n超时后的打印逻辑可以进行自定义了\r\n作为装饰器，可以有多层，但是超过两层时首先要命名一个变量，然后再使用@变量()就可以了\r\n例如有logger _logger __logger三层时\r\n```\r\nimport functools\r\nimport datetime\r\ndef logger(s):\r\n    def _logger(p = lambda name,t : print('call {} took {} '.format(name,t))):\r\n        def __logger(fn):\r\n            @functools.wraps(fn)\r\n            def wrap(*args,**kwargs):\r\n                start = datetime.datetime.now()\r\n                ret = fn(*args,**kwargs)\r\n                end = datetime.datetime.now()\r\n                if (end - start).total_seconds() > s:\r\n                    p(fn.__name__,end - start)\r\n                return ret\r\n            return wrap\r\n        return __logger\r\n    return _logger\r\n```\r\n```\r\nimport time\r\nlogger2s = logger(1)\r\n@logger2s()\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]:sleep(3)\r\nOut[]:call sleep took 0:00:03 \r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "带参数的装饰器",
        "date": "2019-10-12 13:57:56",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dai-can-shu-de-zhuang-shi-qi"
    },
    {
      "content": "先来看一个函数，logger\r\n```\r\ndef logger(fn):\r\n    def warp(*args,**kwargs):\r\n        print('call {}'.format(fn.__name__))\r\n        ret = fn(*args,**kwargs)\r\n        print('{} called'.format(fn.__name__))\r\n        return ret\r\n    return warp\r\n```\r\n这个函数的参数是函数，返回值也是一个函数\r\n先定义一个加函数，作为参数传入logger\r\n```\r\ndef add(x,y):\r\n    return x + y\r\n```\r\n然后定义一个函数\r\n```\r\nIn[]：\r\nloged_add = logger(add)\r\nloged_add(3,5)\r\nOut[]：\r\ncall add\r\nadd called\r\n8\r\n```\r\nloged_add = logger(add)这一步是把add函数作为参数传入logger中，这个时候没有发生任何计算，loged_add是一个函数，这个函数就是wrap\r\n可以查看下loged_add\r\n```\r\nIn[]：loged_add\r\nOut[]：<function __main__.logger.<locals>.warp(*args, **kwargs)>\r\n```\r\n以上这种场景通常用于作为参数的函数执行前后需要一些额外操作\r\n再引入一个东西\r\n```\r\nimport datetime\r\n\r\ndef logger(fn):\r\n    def wrap(*args,**kwargs):\r\n        start = datetime.datetime.now()\r\n        ret = fn(*args,**kwargs)\r\n        end = datetime.datetime.now()\r\n        print('{} called took {}'.format(fn.__name__,end-start))\r\n        return ret\r\n    return wrap\r\n```\r\n可以看看这个函数执行了多久\r\n```\r\nimport time\r\n\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n```\r\nIn[]：loged_sleep = logger(sleep)\r\n```\r\n```\r\nIn[]：loged_sleep(3)\r\nOut[]：sleep called took 0:00:03\r\n```\r\n装饰器\r\n换一种语法糖\r\n```\r\n@logger\r\ndef sleep(x):\r\n    time.sleep(x)\r\n```\r\n这时候，就可以将封装发生在函数定义的时候\r\n这是python的一种语法，可以更方便的去定义我们的函数\r\n@logger的方式和loged_add = logger(add)是等效的\r\n参数是一个函数，返回值是一个函数的函数，就可以作为装饰器\r\n只有用@语法来写的时候，才称为装饰器。\r\n",
      "data": {
        "title": "装饰器",
        "date": "2019-10-10 13:48:00",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zhuang-shi-qi"
    },
    {
      "content": "首先看一个函数\r\n```\r\ndef counter(base):\r\n    def inc(x=1):\r\n        nonlocal base\r\n        base += x\r\n        return base\r\n    return inc\r\n```\r\n```\r\nIn[]：inc = counter(3)\r\nIn[]：inc(3)\r\nOut[]：6\r\n```\r\n```\r\nIn[]：inc(3)\r\nOut[]：9\r\n```\r\n这种返回值是一个函数或者参数是函数的情况，就称为高阶函数\r\n第一种情况：返回值是函数\r\n第二种情况：参数是函数\r\n这两种情况的函数，就叫做高阶函数\r\n高阶函数的作用\r\n首先看一个排序函数，传入一个可迭代对象\r\n```\r\ndef sort(it):\r\n    ret = []\r\n    for x in it:\r\n        for i,e in enumerate(ret):\r\n            if x > e:\r\n                ret.insert(i,x)\r\n                break\r\n        else:\r\n            ret.append(x)\r\n    return ret\r\n```\r\n```\r\nIn[]：sort([1,4,3,8,2,9,0,7])\r\nOut[]：[9, 8, 7, 4, 3, 2, 1, 0]\r\n```\r\n如果要从小到大排列，只需要将大于改成小于就好了，x<e\r\n一般要实现顺序排列和逆序排列需要两个函数，但是可以通过加一个判断，将两个功能通过一个函数实现\r\n```\r\ndef sort(it,r=False):\r\n    ret = []\r\n    for x in it:\r\n        for i,e in enumerate(ret):\r\n            if r:\r\n                if x < e:\r\n                    ret.insert(i,x)\r\n                    break\r\n            else:\r\n                if x > e:\r\n                    ret.insert(i,x)\r\n                    break\r\n        else:\r\n            ret.append(x)\r\n    return ret\r\n```\r\n还可以再次进行优化，将if判断抽出来，作为一个函数\r\n```\r\ndef sort(it,r=False):\r\n    def cmp(a,b):\r\n        if r:\r\n            return a < b\r\n        else:\r\n            return a > b\r\n    ret = []\r\n    for x in it:\r\n        for i,e in enumerate(ret):\r\n            if cmp(x,e):\r\n                ret.insert(i,x)\r\n                break\r\n        else:\r\n            ret.append(x)\r\n    return ret\r\n```\r\n那将cmp函数移到外面行不行呢？可以将cmp作为一个参数传入\r\n```\r\ndef sort(it,cmp=lambda a,b :a < b):\r\n    ret = []\r\n    for x in it:\r\n        for i,e in enumerate(ret):\r\n            if cmp(x,e):\r\n                ret.insert(i,x)\r\n                break        \r\n        else:\r\n            ret.append(x)\r\n    return ret\r\n```\r\n```\r\nIn[]：sort([1,4,3,8,2,9,0,7],lambda a,b :a > b)\r\nOut[]：[9, 8, 7, 4, 3, 2, 1, 0]\r\n\r\n```\r\n```\r\nIn[]：sort([1,4,3,8,2,9,0,7],lambda a,b :a < b)\r\nOut[]：[0, 1, 2, 3, 4, 7, 8, 9]\r\n```\r\n函数作为返回值：通常是用于闭包的场景，需要封装一些变量\r\n函数作为参数：通常是用于大多数逻辑固定，少部分逻辑不固定的场景\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "高阶函数",
        "date": "2019-10-09 11:30:56",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gao-jie-han-shu"
    },
    {
      "content": "生成器其实也是一个函数\r\n```\r\ndef g():\r\n    for x in range(10):\r\n        yield x\r\n```\r\n使用了一个新的关键字yield，没有return会不会报错？\r\n```\r\nIn[]：\r\nr = g()\r\nr\r\nOut[]：<generator object g at 0x000000000613E1B0>\r\n```\r\n可以看到返回的是一个generator\r\n```\r\nIn[]：dir(r)\r\nOut[]：\r\n['__class__',\r\n '__del__',\r\n '__delattr__',\r\n '__dir__',\r\n '__doc__',\r\n '__eq__',\r\n '__format__',\r\n '__ge__',\r\n '__getattribute__',\r\n '__gt__',\r\n '__hash__',\r\n '__init__',\r\n '__init_subclass__',\r\n '__iter__',\r\n '__le__',\r\n '__lt__',\r\n '__name__',\r\n '__ne__',\r\n '__new__',\r\n '__next__',\r\n '__qualname__',\r\n '__reduce__',\r\n '__reduce_ex__',\r\n '__repr__',\r\n '__setattr__',\r\n '__sizeof__',\r\n '__str__',\r\n '__subclasshook__',\r\n 'close',\r\n 'gi_code',\r\n 'gi_frame',\r\n 'gi_running',\r\n 'gi_yieldfrom',\r\n 'send',\r\n 'throw']\r\n```\r\n它有'__iter__'方法，是一个可迭代对象\r\n它有'__next__'方法，是一个迭代\r\n使用next调用一下\r\n```\r\nIn[]：next(r)\r\nOut[]：0\r\n```\r\n```\r\nIn[]：next(r)\r\nOut[]：1\r\n```\r\n返回的是函数中x的值\r\n有一个yield关键字，这个是一个迭代器，是迭代器里面的一个特殊内容，叫生成器\r\n执行完一次r = g()，现场应该被销毁了，但是r还是有值，还是可以继续调用next，事实上，函数的现场并没有被销毁，这就是生成器函数和普通函数不太一样的地方\r\n看下生成器是如何工作的\r\n```\r\ndef gen():\r\n    print('a')\r\n    yield 1\r\n    print('b')\r\n    yield 2\r\n    return 3\r\n```\r\n定义了一个函数，有2个yield，1个return\r\n```\r\nIn[]：g = gen()\r\ng\r\nOut[]：<generator object gen at 0x0000000003259570>\r\n```\r\n理论上，gen里面有return，应该有返回值，但是这个g还是一个generator，说明函数并没有被执行\r\n接下来使用next调用\r\n```\r\nIn[]：next(g)\r\nOut[]：\r\na\r\n1\r\n```\r\n在这里，执行到第一个yield，就停止执行了\r\n再执行一次next(g)\r\n```\r\nIn[]：next(g)\r\nOut[]：\r\nb\r\n2\r\n```\r\n打印出了b，然后到2就又停止了，而之前的a并没有被打印出来，说明现场保留了\r\n再执行一次next(g)\r\n```\r\nIn[]：next(g)\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nStopIteration                             Traceback (most recent call last)\r\n in \r\n----> 1 next(g)\r\n\r\nStopIteration: 3\r\n```\r\n没有更多yield的时候，抛出StopIteration异常，还有一点需要注意的是，这个异常值就是它的返回值，没有返回值的话异常值就为空\r\n总结一下：带yield语句的函数称为生成器函数，生成器函数的返回值是生成器\r\n特点：\r\n* 生成器函数执行的时候，不会执行函数体（注意，这里是说生成器函数执行的时候，不是生成器执行的时候）\r\n* 当next生成器的时候，当前代码会执行到之后的第一个yield，会弹出值，并暂停函数\r\n* 当再次执行next生成器的时候，从上次暂停处开始往下执行\r\n* 当没有多余的yield的时候，会抛出StopIteration异常，如果函数有返回值，异常的value是函数的返回值\r\n  \r\n生成器是惰性求值的，先来写一个计数器\r\n```\r\ndef counter():\r\n    x = 0\r\n    while True:\r\n        x += 1\r\n        yield x\r\n\r\ndef inc(c):\r\n    return next(c)\r\n```\r\n```\r\nIn[]：c = counter()\r\nIn[]: inc(c)\r\nOut[]：1\r\n```\r\n这样每次执行inc(c)都可以得到一个+1的值\r\n还可以封装的更好\r\n```\r\ndef inc():\r\n    c = counter()\r\n    return lambda : next(c)\r\n```\r\n还有一种更好的方法，可以把counter封装到inc里面\r\n```\r\ndef inc():\r\n    def counter():\r\n        x = 0\r\n        while True:\r\n            x += 1\r\n            yield x\r\n    c = counter()\r\n    return lambda : next(c)\r\n```\r\n```\r\nIn[]：incr = inc()\r\nIn[]: incr()\r\nOut[]：1\r\n```\r\n```\r\nIn[]：incr()\r\nOut[]：2\r\n```\r\n难点\r\n```\r\ndef make_inc():\r\n    def counter():\r\n        x = 0\r\n        while True:\r\n            x += 1\r\n            yield x\r\n    c = counter()\r\n    return next(c)\r\n```\r\n```\r\nIn[]：make_inc()\r\nOut[]：1\r\n```\r\n```\r\nIn[]：make_inc()\r\nOut[]：1\r\n```\r\n```\r\nIn[]：make_inc()\r\nOut[]：1\r\n```\r\n为什么再次执行还是得到1？\r\n每次都会初始化一个c，给它一个新的生成器，所以每次都是1\r\n使用lambda的话，只会生成一次c，后面每次都是调用这个函数\r\n应用\r\n斐波那契数列\r\n首先看使用递归实现，递归非常慢\r\n```\r\ndef fib(n):\r\n    if n == 0:\r\n        return 1\r\n    if n == 1:\r\n        return 1\r\n    return fib(n-1) + fib(n-2)\r\n```\r\n还可以使用生成器实现\r\n```\r\ndef fib():\r\n    a = 0\r\n    b = 1\r\n    while True:\r\n        a,b = b,a + b\r\n        yield a\r\n```\r\n```\r\nIn[]：\r\nf = fib()\r\nfor _ in range(5):\r\n    print(next(f))\r\nOut[]：\r\n1\r\n1\r\n2\r\n3\r\n5\r\n```\r\n生成器可以解决递归问题\r\n协程是生成器的高级应用\r\n\r\n\r\n",
      "data": {
        "title": "生成器",
        "date": "2019-09-23 09:42:18",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sheng-cheng-qi"
    },
    {
      "content": "所谓匿名函数就是没有名字的函数，用lambda这个关键字来定义\r\nlambda后面接一个参数x，然后用冒号分隔，然后定义一个函数体\r\n```\r\nlambda x : x + 1\r\n```\r\n冒号后面是不换行的\r\n```\r\nIn[]：(lambda x : x + 1)(3)\r\nOut[]：4\r\n```\r\n```\r\nIn[]：\r\nf = lambda x : x + 1\r\nf(3)\r\nOut[]：4\r\n```\r\n匿名函数（lambda表达式）只能写在一行上，所以也被称为单行函数\r\n匿名函数可以不传参数，直接返回值\r\n```\r\nIn[]：\r\nf = lambda : 0\r\nf()\r\nOut[]：0\r\n```\r\n匿名函数传递多个参数也是可以的\r\n```\r\nIn[]：\r\nf = lambda x,y : x + y\r\nf(3,5)\r\nOut[]：8\r\n```\r\n匿名函数也是支持默认参数的\r\n```\r\nIn[]：\r\n(lambda x,y=3:x + y)(3)\r\nOut[]：6\r\n```\r\n匿名函数也是支持位置可变参数的\r\n```\r\nIn[]：\r\n(lambda *args:args)(*range(3))\r\nOut[]：(0, 1, 2)\r\n```\r\n关键字可变参数也是ok的\r\n```\r\nIn[]：\r\n(lambda *args,**kwargs:print(args,kwargs))(*range(3),**{str(x):x for x in range(3)})\r\nOut[]：(0, 1, 2) {'0': 0, '1': 1, '2': 2}\r\n```\r\n再来看下keyword-only参数\r\n```\r\nIn[]：\r\n(lambda *,x : x)(x = 3)\r\nOut[]：3\r\n```\r\n# 匿名函数的应用\r\n## sorted\r\n```\r\nIn[]：\r\nhelp(sorted)\r\nOut[]：\r\nHelp on built-in function sorted in module builtins:\r\nsorted(iterable, /, *, key=None, reverse=False)\r\n    Return a new list containing all items from the iterable in ascending order.\r\n    A custom key function can be supplied to customize the sort order, and the\r\n    reverse flag can be set to request the result in descending order.\r\n```\r\n里面传一个可迭代对象，key默认是None，然后reverse代表反转\r\n假设有一个User对象，它有name和age两个属性\r\n```\r\nfrom collections import namedtuple\r\nUser = namedtuple('User',['name','age'])\r\n```\r\n然后创建一个User的对象列表\r\n```\r\nusers = [User('yh',18),User('max',16),User('xxx',32)]\r\n```\r\n在不使用匿名函数的情况下，让users根据age来进行排序\r\n```\r\nIn[]：\r\ndef get_age(user):\r\n    return user.age\r\nsorted(users,key=get_age)\r\nOut[]：\r\n[User(name='max', age=16), User(name='yh', age=18), User(name='xxx', age=32)]\r\n```\r\n在使用匿名函数的情况下，让users根据age来进行排序\r\n```\r\nIn[]：sorted(users,key = lambda x : x.age)\r\nOut[]：[User(name='max', age=16), User(name='yh', age=18), User(name='xxx', age=32)]\r\n```\r\n当函数作为参数时，需要使用匿名函数\r\n## map\r\n```\r\nIn[]：map(lambda x:x*2,[1,2,3])\r\nOut[]：<map at 0x64671d0>\r\n```\r\n但是在python3中把map改成一个生成器了，可以使用list转换一下\r\n```\r\nIn[]：list(map(lambda x:x*2,[1,2,3]))\r\nOut[]：[2, 4, 6]\r\n```\r\n## Filter\r\n把每个可迭代对象传进来，如果函数返回True，就存在，返回False，就不存在\r\n```\r\nIn[]：list(filter(lambda x:x<30,[16,18,32]))\r\nOut[]：[16, 18]\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "匿名函数",
        "date": "2019-09-19 22:45:17",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ni-ming-han-shu"
    },
    {
      "content": "函数的执行流程\r\n当调用函数的时候，解释器会把当前现场压栈，然后执行被调函数。被调函数执行完成，解释器弹出当前栈顶，恢复现场\r\n递归函数\r\n程序调用自身的编程技巧称为递归\r\n```\r\ndef fib(n):\r\n    if n == 0:\r\n        return 1\r\n    if n == 1:\r\n        return 1\r\n    return fib(n-1) + fib(n-2)\r\n```\r\n**递归函数必须要有退出条件**",
      "data": {
        "title": "函数的执行流程 & 递归函数",
        "date": "2019-09-19 22:24:55",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "han-shu-de-zhi-xing-liu-cheng-and-di-gui-han-shu"
    },
    {
      "content": "# 定义\r\n一个变量的可见范围叫做这个变量的作用域\r\n# 全局作用域\r\n# 局部作用域\r\n变量的作用域为变量定义同级的作用域，也就是在哪一个级别定义的，在哪一个级别就可见\r\n# 上、下级作用域\r\n上级作用域对下级作用域是只读的，read-only的\r\n不同作用域变量不可见，但是下级作用域可以对上级作用域的变量只读可见\r\n# 全局变量global\r\nglobal关键字可以提升变量作用域为全局变量\r\nglobal的提升只对本作用域有用，那么我们需要让他在其他局部作用域有用，就需要再标记\r\n# 闭包函数\r\n```\r\ndef counter():\r\n    c = [0]\r\n    def inc():\r\n        c[0] += 1\r\n        return c[0]\r\n    return inc\r\nf = counter()\r\nf()\r\n```\r\n这种形式我们称为闭包，函数已经结束，但是函数内部部分变量的引用还存在\r\n理论上执行完f = counter()后，这个c已经没有了，但是我们通过inc可以继续访问，这种就称为闭包\r\n# 局部变量\r\n```\r\ndef counter():\r\n    x = 0\r\n    def inc():\r\n        nonlocal x\r\n        x += 1\r\n        return x\r\n    return inc\r\nf = counter()\r\nf()\r\n```\r\nnonlocal关键字用来标记一个变量由他的上级作用域定义，通过nonlocal标记的变量可读可写\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python函数的作用域",
        "date": "2019-09-16 17:02:19",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-han-shu-de-zuo-yong-yu"
    },
    {
      "content": "函数是Python里组织代码的最小单元\r\n定义函数的时候，并不会执行函数体\r\n当调用函数的时候，才会执行其中的语句块\r\nPython在导入模块的时候，是会去执行一遍该文件\r\n# 函数参数\r\n位置参数\r\n关键字参数\r\n注意：**当位置参数和关键字参数混合使用时，位置参数必须在前面，否则会报语法错误**\r\n默认参数\r\n参数可以有默认值，当一个参数有默认值时，调用时如果不传递此此参数，会有默认值\r\n注意：带默认值的参数必须在不带默认值的参数之后\r\n位置可变参数\r\n在参数前面加一个星号\r\n```\r\nIn[]：\r\ndef sum(*lst):\r\n    ret = 0\r\n    for x in lst:\r\n        ret += x\r\n    return ret\r\nprint(sum(1,2,3))\r\nOut[]：\r\n6\r\n```\r\n关键字可变参数\r\n```\r\nIn[]：\r\ndef connect(**kwargs):\r\n    print(type(kwargs))\r\n    print(kwargs)\r\nconnect(host='127.0.0.1',port=3601)\r\nOut[]：\r\n<class 'dict'>\r\n{'host': '127.0.0.1', 'port': 3601}\r\n```\r\n注意：当位置可变参数和关键字可变参数一起使用时，位置可变参数必须在前面\r\n通常来说：\r\n默认参数靠后\r\n可变参数靠后\r\n默认参数和可变参数不同时出现\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python函数的基础",
        "date": "2019-09-16 10:11:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-han-shu-de-ji-chu"
    },
    {
      "content": "# 可迭代对象\r\n```\r\nIn[]：\r\nr = range(10)\r\nr.__iter__\r\nOut[]：\r\n<method-wrapper '__iter__' of range object at 0x0000000006013570>\r\n```\r\n有__iter__方法的对象叫可迭代对象\r\nfor in语句需要可迭代对象\r\n# 迭代器\r\n迭代器是可迭代对象\r\n```\r\nIn[]：\r\nit = iter(range(10))\r\nit.__next__\r\nOut[]：\r\n<method-wrapper '__next__' of range_iterator object at 0x000000000628CD50>\r\n```\r\n有__next__方法的可迭代对象叫迭代器\r\n可迭代对象可以转换为迭代器\r\niter函数可以把一个可迭代对象转换为迭代器\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python可迭代对象与迭代器",
        "date": "2019-09-10 15:03:31",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ke-die-dai-dui-xiang-yu-die-dai-qi"
    },
    {
      "content": "解析式分为：\r\n* 列表解析式\r\n* 生成器解析式\r\n* 集合解析式\r\n* 字典解析式\r\n\r\n# 列表解析式\r\n## 定义\r\n通用语法：'[expr for e in iterator]'\r\n列表解析式的优点：\r\n代码简介，可读性强\r\n效率比普通的迭代稍高，但不是数量级上的，只是稍微有一点\r\n```\r\nIn[]：\r\n%%timeit\r\nret = []\r\nfor i in range(10000):\r\n    ret.append(i)\r\nOut[]：\r\n551 µs ± 10.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\r\nIn[]：\r\n%%timeit\r\nret = [i for i in range(10000)]\r\nOut[]：\r\n278 µs ± 2.23 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\r\n```\r\n## 解析式变体\r\n带if语句的列表解析\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nret = []\r\nfor x in lst:\r\n    if x % 2 == 0:\r\n        ret.append(x)\r\nret\r\nOut[]：\r\n[0, 2, 4, 6, 8]\r\nIn[]：\r\nret = [x for x in lst if x % 2 == 0]\r\nret\r\nOut[]：\r\n[0, 2, 4, 6, 8]\r\n```\r\n事实上也可以是多个if的组合\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nret = [x for x in lst if x > 0 if x < 5]\r\nret\r\nOut[]：\r\n[1, 2, 3, 4]\r\n```\r\n等效于：\r\n```\r\nIn[]：\r\nret = []\r\nfor x in lst:\r\n    if x > 0:\r\n        if x < 5:\r\n            ret.append(x)\r\nret\r\nOut[]：\r\n[1, 2, 3, 4]\r\n```\r\n解析式前面有没有可能放两个元素呢？\r\n```\r\nIn[]：\r\n[x,y for x in range(5) for y in range(5,10)]\r\nOut[]：\r\n File \"<ipython-input-19-2ffe676038e5>\", line 1\r\n    [x,y for x in range(5) for y in range(5,10)]\r\n           ^\r\nSyntaxError: invalid syntax\r\n```\r\n可以将其用一个元组封装起来\r\n```\r\nIn[]：\r\n[(x,y) for x in range(5) for y in range(5,10)]\r\nOut[]：\r\n[(0, 5),\r\n (0, 6),\r\n (0, 7),\r\n (0, 8),\r\n (0, 9),\r\n (1, 5),\r\n (1, 6),\r\n (1, 7),\r\n (1, 8),\r\n (1, 9),\r\n (2, 5),\r\n (2, 6),\r\n (2, 7),\r\n (2, 8),\r\n (2, 9),\r\n (3, 5),\r\n (3, 6),\r\n (3, 7),\r\n (3, 8),\r\n (3, 9),\r\n (4, 5),\r\n (4, 6),\r\n (4, 7),\r\n (4, 8),\r\n (4, 9)]\r\n```\r\n## 三元表达式\r\n语法：'x if cond else y'\r\n* 当条件（cond）满足时，返回x\r\n* 当条件不满足时，返回y\r\n\r\n```\r\nIn[]：\r\n[x**2 if x % 2 == 0 else x**3 for x in range(10)]\r\nOut[]：\r\n[0, 1, 4, 27, 16, 125, 36, 343, 64, 729]\r\n```\r\n三元表达式只能使用双分支if else\r\n# 生成器解析式\r\n列表解析式中的中括号变成小括号，就称为生成器解析式了\r\n生成器解析式返回的是一个生成器\r\n生成器的有点是：\r\n* 不占内存\r\n* 惰性求值\r\n\r\n```\r\nIn[]：\r\ndef fn(x):\r\n    print('executed')\r\n    return x\r\ng = (fn(x) for x in range(10))\r\nnext(g)\r\nOut[]：\r\nexecuted\r\n0\r\n```\r\n* 生成器都是迭代器\r\n* 生成器是无法使用下标访问的\r\n\r\n# 集合解析\r\n```\r\nIn[]：\r\ns = {x for x in range(10)}\r\nprint(s)\r\nprint(type(s))\r\nOut[]：\r\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\r\n<class 'set'>\r\n```\r\n# 字典解析\r\n```\r\nIn[]：\r\nd = {str(x):x for x in range(10)}\r\nprint(d)\r\nprint(type(d))\r\nOut[]：\r\n{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}\r\n<class 'dict'>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python解析式",
        "date": "2019-09-10 11:17:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-jie-xi-shi"
    },
    {
      "content": "为什么字典可以做到近似O(1)的时间复杂度？\r\n# 字典的存储结构\r\n字典是通过列表来实现的，实现的方式大致分为两种：\r\n* 拉链法\r\n* 开地址法\r\n\r\n",
      "data": {
        "title": "Python如何实现一个字典",
        "date": "2019-09-10 11:04:39",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ru-he-shi-xian-yi-ge-zi-dian"
    },
    {
      "content": "# 定义\r\n定义字典的方法：\r\n第一种：直接使用dict()来定义\r\n```\r\nIn[]：\r\nd = dict(\r\nname = 'yh',\r\naddress = '呼呼')\r\nd\r\nOut[]：\r\n{'name': 'yh', 'address': '呼呼'}\r\n```\r\n第二种：直接使用花括号括起来\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 2}\r\n```\r\n第三种：\r\n1、可迭代对象的元素必须是一个二元组\r\n2、二元组的第0个元素是字典的key，第一个元素为字典的value\r\n```\r\nIn[]：\r\nd = dict([('a',1),('b',2)])\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 2}\r\n```\r\n第四种：传入的可迭代对象元素为key，值为None\r\n```\r\nIn[]：\r\nd = dict.fromkeys(range(5))\r\nd\r\nOut[]：\r\n{0: None, 1: None, 2: None, 3: None, 4: None}\r\n```\r\n传入的可迭代对象的元素为key，值为abc\r\n```\r\nIn[]：\r\nd = dict.fromkeys(range(5),'abc')\r\nd\r\nOut[]：\r\n{0: 'abc', 1: 'abc', 2: 'abc', 3: 'abc', 4: 'abc'}\r\n```\r\n定义一个空字典可以使用{}或者dict()，定义一个空集合需要使用set()\r\n# 增加\r\n第一种：直接使用key作为下标，对某个不存在的下标赋值\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd['c'] = 3\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 2, 'c': 3}\r\n```\r\n第二种：通过update方法同时更新多个键值对，也可以将一个新的字典更新到另一个字典里\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.update([('c',3),('p',4)])\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 2, 'c': 3, 'p': 4}\r\n```\r\n直接传入字典更加方便，若key已存在，则会更新对应的值\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.update({'c':3,'d':4})\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\r\n```\r\n# 修改\r\n当key存在的时候，对下标赋值，会修改这个key对应的value\r\n也可以使用update修改\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd['a'] = 3\r\nd\r\nOut[]：\r\n{'a': 3, 'b': 2}\r\n```\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.update({'b':4})\r\nd\r\nOut[]：\r\n{'a': 1, 'b': 4}\r\n```\r\n# 删除\r\n## dict.pop\r\npop需要传入一个key，如果key存在会返回这个key的value\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.pop('a')\r\nOut[]：\r\n1\r\n```\r\n如果key不存在会抛出KeyError，并且会把这个键一起返回\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.pop('c')\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nKeyError                                  Traceback (most recent call last)\r\n<ipython-input-20-72feaa87d842> in <module>\r\n      1 d = {'a':1,'b':2}\r\n----> 2 d.pop('c')\r\nKeyError: 'c'\r\n```\r\n但是当删除了不存在的key，并且指定了默认值的时候，就不会抛出KeyError\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.pop('c','default')\r\nOut[]：\r\n'default'\r\n```\r\n## dict.popitem\r\n随机返回删除的一个kv对的二元组\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.popitem()\r\nOut[]：\r\n('b', 2)\r\n```\r\n## dict.clear\r\n清空一个字典\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.clear()\r\nd\r\nOut[]：\r\n{}\r\n```\r\n## del\r\ndel语句是删除一个键的引用，相当于dict.pop(key)\r\n但是通常不用del，都用pop\r\n# 访问\r\n## 单个元素的访问\r\n直接使用下标访问，当Key不存在的时候抛出KeyError\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd['a']\r\nOut[]：\r\n1\r\n```\r\nget方法访问不存在的key的时候会返回默认值，未设置时为None，设置时返回设定值\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2}\r\nd.get('c','default')\r\nOut[]：\r\n'default'\r\n```\r\n## 字典的遍历\r\n直接使用for in遍历字典，遍历的是字典的key\r\n遍历字典的值可以使用values\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2,'c':3}\r\nfor v in d.values():\r\n    print(v)\r\nOut[]：\r\n1\r\n2\r\n3\r\n```\r\nd.items()使用最多，返回一个可迭代对象，元素是字典的所有kv对\r\n```\r\nIn[]：\r\nd = {'a':1,'b':2,'c':3}\r\nfor k,v in d.items():\r\n    print(k,'=>',v)\r\nOut[]：\r\na => 1\r\nb => 2\r\nc => 3\r\n```\r\n# 字典的限制\r\n* 字典的key不能重复\r\n* 字典的key需要可hash\r\n* 字典也不能做字典的key\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python字典及常用操作",
        "date": "2019-09-04 16:58:27",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-dian-ji-chang-yong-cao-zuo"
    },
    {
      "content": "# 交集\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.intersection(s2)\r\nOut[]：\r\n{2, 3}\r\n```\r\ns1.intersection(s2)将得到s1集合与s2集合的交集，是**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns2.intersection_update(s1)\r\ns2\r\nOut[]：\r\n{2, 3}\r\n```\r\nset.intersection_update方法**原地修改，返回None**\r\n接下来看下python集合运算里的运算符重载\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1 & s2\r\nOut[]：\r\n{2, 3}\r\n```\r\n**set重载了按位与运算符&为求交集的运算**\r\n# 差集\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.difference(s2)\r\nOut[]：\r\n{1}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.difference_update(s2)\r\ns1\r\nOut[]：\r\n{1}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1 - s2\r\nOut[]：\r\n{1}\r\n```\r\n# 对称差集\r\n如果把两个集合A和B看成是一个全集，对称差集就是交集的补集\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.symmetric_difference(s2)\r\nOut[]：\r\n{1, 4}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.symmetric_difference_update(s2)\r\ns1\r\nOut[]：\r\n{1, 4}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1 ^ s2\r\nOut[]：\r\n{1, 4}\r\n```\r\n# 并集\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.union(s2)\r\nOut[]：\r\n{1, 2, 3, 4}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1.update(s2)\r\ns1\r\nOut[]：\r\n{1, 2, 3, 4}\r\n```\r\n```\r\nIn[]：\r\ns1 = {1,2,3}\r\ns2 = {2,3,4}\r\ns1 | s2\r\nOut[]：\r\n{1, 2, 3, 4}\r\n```\r\n# 子集、超集\r\n判断s2是否是s1的子集\r\n```\r\nIn[]：\r\ns1 = {1,2,3,4}\r\ns2 = {2,3}\r\ns2.issubset(s1)\r\nOut[]：\r\nTrue\r\n```\r\n判断s1是否是s2的超集\r\n```\r\nIn[]：\r\ns1 = {1,2,3,4}\r\ns2 = {2,3}\r\ns1.issuperset(s2)\r\nOut[]：\r\nTrue\r\n```\r\n# 集合的应用\r\n* 去重\r\n* 集合运算更快\r\n\r\n1、权限认证，例如：具有权限要求满足A、B、C中任意一项，有一个用户具有权限B、C、D，那么此用户是否有权限？\r\n通过isdisjoin的方法，返回False即可\r\nisdisjoin判断2个集合是否有交集，如果有交集返回False，没有交集返回True\r\n2、有一个任务列表，存储全部的任务，有一个列表存储已经完成的任务，找出未完成的任务\r\n用差集\r\n# 集合的限制\r\n**集合元素必须可hash**\r\n```\r\nIn[]：\r\nhash([1,2,3])\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-82-35e31e935e9e> in <module>\r\n----> 1 hash([1,2,3])\r\nTypeError: unhashable type: 'list'\r\nIn[]：\r\n{[1,2,3]}\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-83-f70e4b6b8fd1> in <module>\r\n----> 1 {[1,2,3]}\r\nTypeError: unhashable type: 'list'\r\n```\r\n",
      "data": {
        "title": "Python集合运算",
        "date": "2019-09-04 14:29:05",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ji-he-yun-suan"
    },
    {
      "content": "# 定义与初始化\r\n集合没有重复元素\r\nset()可以对可迭代对象进行转化\r\n```\r\nIn[]：\r\ns = {1,2,3}\r\ns\r\nOut[]：\r\n{1, 2, 3}\r\n```\r\n# 集合增加\r\n```\r\nIn[]：\r\ns = {0,1,2}\r\ns.add(3)\r\ns\r\nOut[]：\r\n{0, 1, 2, 3}\r\n```\r\n在增加已存在元素时，set集合并不会被追加新元素\r\n```\r\nIn[]：\r\ns = {0,1,2,3}\r\ns.add(3)\r\ns\r\nOut[]：\r\n{0, 1, 2, 3}\r\n```\r\n再来看一个方法\r\n```\r\nIn[]：\r\nhelp(set.update)\r\nOut[]：\r\n**Help on method_descriptor:\r\nupdate(...)\r\n    Update a set with the union of itself and others.**\r\n```\r\nupdate方法会把自己和别人联合起来，但是会去重，**没有返回值，原地修改**\r\n```\r\nIn[]：\r\ns = {0,1,2,3}\r\ns.update(range(4,7))\r\ns\r\nOut[]：\r\n{0, 1, 2, 3, 4, 5, 6}\r\n```\r\n```\r\nIn[]：\r\ns = {0,1,2,3,4,5,6}\r\ns.update(range(4,9))\r\ns\r\nOut[]：\r\n{0, 1, 2, 3, 4, 5, 6, 7, 8}\r\n```\r\n# 集合删除\r\n## set.remove\r\n```\r\nIn[]：\r\nhelp(set.remove)\r\nOut[]：\r\nHelp on method_descriptor:\r\nremove(...)\r\n    Remove an element from a set; it must be a member.\r\n    If the element is not a member, raise a KeyError.\r\n```\r\n我们看remove的函数签名，2个点：\r\n* 会从集合中删除你传入的变量，但是这个变量必须是集合中已有的元素\r\n* 如果这个元素不存在，是会抛出异常的\r\n```\r\nIn[]：\r\ns = set(range(9))\r\ns.remove(0)\r\ns\r\nOut[]：\r\n{1, 2, 3, 4, 5, 6, 7, 8}\r\n```\r\nremove**原地修改，不返回值**\r\n## set.pop\r\n```\r\nIn[]：\r\nhelp(set.pop)\r\nOut[]：\r\nHelp on method_descriptor:\r\npop(...)\r\n    Remove and return an arbitrary set element.\r\n    Raises KeyError if the set is empty.\r\n```\r\n从函数签名得知，pop和remove有一个区别，就是pop会return这个删除的值\r\n同时，如果集合为空了，还要pop的话，会抛出KeyError信息\r\n## set.discard\r\n```\r\nIn[]：\r\nhelp(set.discard)\r\nOut[]：\r\nHelp on method_descriptor:\r\ndiscard(...)\r\n    Remove an element from a set if it is a member.\r\n    If the element is not a member, do nothing.\r\n```\r\ndiscard可以指定删除哪个元素，而不是像pop那样，只能从队首或者队尾删除\r\n**原地修改，不返回值**\r\ndiscard删除不存在的元素时，什么也不做\r\n# 修改\r\n集合不能修改单个元素\r\n# 查找\r\n**集合不能通过索引访问，因为集合不是一个线性结构**\r\n# 成员运算符\r\n因为集合的成员运算和其他线性结构的时间复杂度不同\r\n做一个简单的效率计算\r\n使用%%timeit，这是ipython提供的一个magic\r\n```\r\nIn[]：\r\nlst = list(range(1000000))\r\ns = set(range(1000000))\r\nIn[]：\r\n%%timeit\r\n-1 in lst\r\nOut[]：\r\n8.91 ms ± 126 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\r\nIn[]：\r\n%%timeit\r\n-1 in s\r\nOut[]：\r\n32.3 ns ± 0.193 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\r\n```\r\n在list里面做100次循环，得到平均值是8.91ms上下浮动126us，但是在set中，效率是32.3ns上下浮动0.193ns\r\n再来看一个：\r\n```\r\nIn[]：\r\nlst = list(range(100))\r\ns = set(range(100))\r\nIn[]：\r\n%%timeit\r\n-1 in lst\r\nOut[]：\r\n885 ns ± 3.95 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)\r\nIn[]：\r\n%%timeit\r\n-1 in s\r\nOut[]：\r\n32.2 ns ± 0.182 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\r\n```\r\n做成员运算时，**列表的效率和列表的规模有关**\r\n做成员运算时，**集合的效率和集合的规模无关**\r\n成员运算\r\n* 集合的效率：O(1)\r\n* 列表的效率：O(n)\r\n\r\n所以可能的话，当你要做成员运算的时候，就把列表、元组转化成集合做\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python集合及常用操作",
        "date": "2019-09-04 09:36:03",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ji-he-ji-chang-yong-cao-zuo"
    },
    {
      "content": "# 解构\r\n先来看一个栗子：\r\n```\r\nIn[]：\r\nx = 1\r\ny = 2\r\nx,y = y,x\r\nprint(x,y)\r\nOut[]：\r\n2 1\r\n```\r\n结构顾名思义，把一个整体拆成多个小个体\r\n```\r\nIn[]：\r\nlst = [1,2]\r\nfirst,second = lst\r\nprint(first,second)\r\nOut[]：\r\n1 2\r\n```\r\n这样的一个过程我们称之为解构\r\n**解构**：按照元素顺序，把**线性结构**的元素赋值给变量\r\n# 封装\r\n封装是解构的逆向操作\r\n```\r\nIn[]：\r\nt = 1,2\r\nt\r\nOut[]：\r\n(1, 2)\r\n```\r\n# python3中解构的变化\r\n## 八大变体\r\n第一种变体：head代表第一个元素，tail是最后一个元素，mid是中间所有元素：\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nhead,*mid,tail = lst\r\nprint(head)\r\nprint(mid)\r\nprint(tail)\r\nOut[]：\r\n0\r\n[1, 2, 3, 4, 5, 6, 7, 8]\r\n9\r\n```\r\n第二种变体：加星号的tail是除了第一个外的所有元素：\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nhead,*tail = lst\r\nprint(head)\r\nprint(tail)\r\nOut[]：\r\n0\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n```\r\n第三种变体：加星号的head是除了最后一个外的所有元素\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\n*head,tail = lst\r\nprint(head)\r\nprint(tail)\r\nOut[]：\r\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\r\n9\r\n```\r\n第四种变体：左边只有一个加星号的变量，**这个是不行的**\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\n*lst2 = lst\r\nOut[]：\r\n*lst2 = lst\r\n  File \"<ipython-input-14-d0dbc72204e9>\", line 5\r\nSyntaxError: starred assignment target must be in a list or tuple\r\n```\r\n第五种变体：左边有两个或两个以上加星号的，**是不行的**\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nhead,*m1,*m2,tail = lst\r\nOut[]：\r\n  File \"<ipython-input-15-8f61a35156b2>\", line 5\r\nSyntaxError: two starred expressions in assignment\r\n```\r\n第六种变体：左边加上一些其他变量\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nfirst,second,*other,last = lst\r\nprint(first)\r\nprint(second)\r\nprint(other)\r\nprint(last)\r\nOut[]：\r\nlst = list(range(10))\r\nfirst,second,*other,last = lst\r\nprint(first)\r\nprint(second)\r\nprint(other)\r\nprint(last)\r\nlst = list(range(10))\r\nfirst,second,*other,last = lst\r\nprint(first)\r\nprint(second)\r\nprint(other)\r\nprint(last)\r\n0\r\n1\r\n[2, 3, 4, 5, 6, 7, 8]\r\n9\r\n```\r\n第七种变体：当左边变量超过右边元素个数的时候，**是不允许的**\r\n```\r\nIn[]：\r\nlst = list(range(2))\r\nv1,v2,v3 = lst\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-20-cc6bc96adc53> in <module>\r\n      1 lst = list(range(2))\r\n----> 2 v1,v2,v3 = lst\r\nValueError: not enough values to unpack (expected 3, got 2)\r\n```\r\n第八种变体：当左边变量数小于右边变量数，且左边没有加星号的变量，**是不允许的**\r\n```\r\nIn[]：\r\nlst = list(range(10))\r\nv1,v2,v3 = lst\r\nOut[]：\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-21-03d03897cf0b> in <module>\r\n      1 lst = list(range(10))\r\n----> 2 v1,v2,v3 = lst\r\nValueError: too many values to unpack (expected 3)\r\n```\r\n**小结：**\r\n元素按照顺序赋值给变量\r\n变量和元素必须匹配\r\n加星号变量，可以接受任意个数的元素\r\n加星号的变量不能单独出现\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python解构与封装",
        "date": "2019-09-04 08:34:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python"
    },
    {
      "content": "# 定义\r\n线性结构共同特点：\r\n* 可迭代\r\n* 可以用len方法获取长度\r\n* 可以通过索引访问\r\n* 可以切片\r\n\r\n# enumerate\r\n```\r\nIn[]：\r\nenumerate((1,2,3))\r\nOut[]：\r\n<enumerate at 0x6059750>\r\n```\r\n返回一个可迭代对象，再来看看这个可迭代对象是什么\r\n```\r\nIn[]：\r\nlist(enumerate((1,2,3)))\r\nOut[]：\r\n[(0, 1), (1, 2), (2, 3)]\r\n```\r\n实现一个enumerate函数\r\n```\r\nIn[]：\r\ndef new_enumerate(iterator):\r\n    i = 0\r\n    for v in iterator:\r\n        yield i,v\r\n        i += 1\r\nlist(new_enumerate((1,2,3)))\r\nOut[]：\r\n[(0, 1), (1, 2), (2, 3)]\r\n```\r\n需要同时获取索引和value时用这个函数\r\n# 迭代器\r\n可迭代对象可以通过iter方法转换为迭代器\r\nnext可以迭代迭代器，不可以迭代可迭代对象\r\n当next将迭代器的元素都迭代过一遍后，再迭代一次就会抛出StopIteration\r\n```\r\nIn[]：\r\nit = iter(list((1,2,3)))\r\nnext(it)\r\nOut[]：\r\n1\r\n```\r\n# 切片操作\r\nlst\\[start:stop\\]，可以访问这个list一段，从start开始，到stop结束，不包含stop，并且是原地不修改，有返回值\r\n* start超出索引范围时，start = 0\r\n* stop超出索引范围时，stop = -0\r\n* 当start>=stop时，返回空列表\r\n* 负数索引，实际上等于len(lst) + index\r\n\r\nlst[::-1]可以直接将列表倒序\r\n",
      "data": {
        "title": "Python线性结构与切片",
        "date": "2019-09-03 17:29:44",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-xian-xing-jie-gou-yu-qie-pian"
    },
    {
      "content": "# 定义\r\n* str是文本序列\r\n* bytes是字节序列\r\n\r\n## 区别\r\n* 文本是有编码的，例如：utf8、gbk\r\n* 字节没有编码\r\n* 文本的编码指的是字符如何使用字节来表示\r\n\r\n## 编码\r\n* 单字节编码，例如：ascii\r\n* 多字节编码，例如：utf8\r\n\r\n**注意：python3中，字符串默认使用utf8编码**\r\n而把字符串经过编码后的数据类型，我们称为bytes\r\n以下这段编码就是用utf8编码表示的字节：\r\n```\r\nIn[]：\r\ns = '人人都是Pythonista'\r\ns.encode()\r\nOut[]：\r\nb'\\xe4\\xba\\xba\\xe4\\xba\\xba\\xe9\\x83\\xbd\\xe6\\x98\\xafPythonista'\r\n```\r\nbytes是可以转化成字符串的\r\n```\r\nIn[]：\r\ns = '人人都是Pythonista'\r\nbt = s.encode()\r\nbt.decode()\r\nOut[]：\r\n'人人都是Pythonista'\r\n```\r\n**在python3中，socket只能用bytes**\r\n**注意：在python2中不区分bytes和str**\r\n# bytes\r\n## bytes定义\r\nstr的所有操作，bytes都支持\r\n* bytes由str通过encode方法转化得到\r\n* 通过b前缀定义bytes\r\n\r\n```\r\nIn[]：\r\nbt = b'abc'\r\ntype(bt)\r\nOut[]：\r\nbytes\r\n```\r\n## bytes操作\r\nbytes的操作除了encode外，str操作都有对应bytes的版本，但是传入参数也必须是bytes，如果传入字符串会报错\r\n栗子（使用socket发送十六进制报文）：\r\n1. 将字符串转换为十六进制字节\r\n2. 将十六进制字节转换为字符串\r\n```\r\nIn[]：\r\na = 'aabbccddeeff'\r\na_bytes = bytes.fromhex(a)\r\nprint(a_bytes)\r\naa = a_bytes.hex()\r\nprint(aa)\r\nOut[]：\r\nb'\\xaa\\xbb\\xcc\\xdd\\xee\\xff'\r\naabbccddeeff\r\n```\r\n# bytearray\r\nbytearray是bytes的可变版本\r\nstr和bytes是不可变的\r\nbytearray是可变类型，进行一次替换\r\n```\r\nIn[]：\r\nba = bytearray(b'abc')\r\nba[0] = int(b'D'.hex(),16)\r\nba\r\nOut[]：\r\nbytearray(b'Dbc')\r\n```\r\n这里要注意几个地方\r\n* bytearray更新的时候，也是一个一个字节更新的，不是一个字符串\r\n* 要把字节转换成十六进制数进行更替\r\n## 使用场景\r\n图像处理\r\n修改图片时，图片保存成了字节，需要一个可变版本的bytes\r\n## bytearray的方法\r\n相对bytes来说，多了insert，append，extend，pop，remove，clear，reverse\r\n其实就是多了list的那些方法，并且可以索引操作\r\n但是和修改bytearray一样，所有的方法中，都需要用int来表示，而非bytes本身\r\nint必须在0~256这个范围内，即8位的无符号整数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python字符串与bytes",
        "date": "2019-09-03 16:10:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-yu-bytes"
    },
    {
      "content": "# print style字符串格式化\r\n通过在字符串后面追加一个百分号，再追加一个元组，元组里面加上你要组合的字符串\r\n传入参数顺序替换占位符，返回替换后的字符串\r\n```\r\nIn[]：\r\n'i use %s,i am %d' % ('python',18)\r\nOut[]：\r\n'i use python,i am 18'\r\n```\r\n**注意：当在拼接sql的时候，一定要用这种print style，%的方式可以帮助我们避免恶意攻击者sql注入**\r\n# format方法\r\nformat方法使用{}作为占位符\r\nformat可以在占位符里面加数字，指定format参数的位置\r\n```\r\nIn[]：\r\ns = 'i use {1},i am {0}'\r\ns.format(18,'python')\r\nOut[]：\r\n'i use python,i am 18'\r\n```\r\n参数可以通过指定位置方式多次使用\r\n```\r\nIn[]：\r\n'{0}{0}'.format('python')\r\nOut[]：\r\n'pythonpython'\r\n```\r\n可以在占位符里加标识符，来使用关键字参数\r\n```\r\nIn[]：\r\n'{who} {do} {what}'.format(who='everyone',do='use',what='python')\r\nOut[]：\r\n'everyone use python'\r\n```\r\n同时支持使用位置和关键字参数\r\n**位置参数必须要在前面，关键字参数在后面**\r\n```\r\nIn[]：\r\n'{0} {who} {do} {what}'.format('今天',who='everyone',do='use',what='python')\r\nOut[]：\r\n'今天 everyone use python'\r\n```\r\n若要打印{}，则在外面加一层{}即可\r\n```\r\nIn[]：\r\n'{{}}'.format()\r\nOut[]：\r\n'{}'\r\n```\r\n```\r\nIn[]：\r\n'{{{}}}'.format(18)\r\nOut[]：\r\n'{18}'\r\n```\r\n# f前缀\r\npython3.6开始新增了一项新的前缀，f前缀\r\n```\r\nIn[]：\r\nwho = 'everyone'\r\ndo = 'use'\r\nwhat = 'python'\r\nf'{who} {do} {what}'\r\nOut[]：\r\n'everyone use python'\r\n```\r\n当在代码块的上文中已经提及了这些变量，可以直接用f前缀加上这些变量来组合\r\n举个栗子：\r\n```\r\nIn[]：\r\ntoken = 'asdfasdfasdfasdf'\r\nuser_id = 1\r\ndt = '2019-09-03'\r\nurl = f'http://you-are-one.com/?token={token}&user_id={user_id}&dt={dt}'\r\nurl\r\nOut[]：\r\n'http://you-are-one.com/?token=asdfasdfasdfasdf&user_id=1&dt=2019-09-03'\r\n```\r\n",
      "data": {
        "title": "Python字符串格式化",
        "date": "2019-09-03 14:29:12",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-ge-shi-huahua"
    },
    {
      "content": "# 定义\r\n单/双引号只能定义单行字符串，不能定义多行字符串\r\n三引号可以定义多行字符串\r\n# 转义\r\n转义符号用“\\”\r\n转义符号还可以使用前缀关键字r，它代表的意思是：后面的字符串是raw string\r\n特别是写正则的时候需要加上r前缀\r\nu前缀代表unicode字符串\r\nb前缀代表bytes\r\n# 下标操作\r\n字符串可以使用下标访问\r\n**字符串是不可变的**\r\n**字符串是迭代器，是可迭代对象**\r\nlist()可以将字符串转化为列表\r\n```\r\nIn[]：\r\ns = 'python'\r\nlist(s)\r\nOut[]：\r\n['p', 'y', 't', 'h', 'o', 'n']\r\n```\r\ncount()可以计算字符串中某个字符出现的次数\r\n```\r\nIn[]：\r\ns = '霍霍霍霍霍元甲'\r\ns.count('霍')\r\nOut[]：\r\n5\r\n```\r\nindex()可以搜索字符串中某个字符的位置\r\n```\r\nIn[]：\r\ns = '霍霍霍霍霍元甲'\r\ns.index('霍')\r\nOut[]：\r\n0\r\n```\r\n# 字符串的操作\r\n## join\r\njoin是字符串的方法，参数是可迭代对象，接受者是分隔符\r\n```\r\nIn[]：\r\nl = ['i','use','python']\r\n','.join(l)\r\nOut[]：\r\n'i,use,python'\r\n```\r\n## 字符串分割\r\n### str.split\r\n```\r\nIn[]：\r\nhelp(str.split)\r\nOut[]：\r\nHelp on method_descriptor:\r\nsplit(self, /, sep=None, maxsplit=-1)\r\n    Return a list of the words in the string, using sep as the delimiter string.\r\n    sep\r\n      The delimiter according which to split the string.\r\n      None (the default value) means split according to any whitespace,\r\n      and discard empty strings from the result.\r\n    maxsplit\r\n      Maximum number of splits to do.\r\n      -1 (the default value) means no limit.\r\n```\r\nstr.split()，默认使用空格分割，当遇到多个空格，默认会当作一个空格处理\r\n```\r\nIn[]：\r\ns = \"life        is short\"\r\ns.split()\r\nOut[]：\r\n['life', 'is', 'short']\r\n```\r\n但是，当指定了一个空格为分隔符，一个空格就当作一个空格处理\r\n```\r\nIn[]：\r\ns = \"life        is short\"\r\ns.split(' ')\r\nOut[]：\r\n['life', '', '', '', '', '', '', '', 'is', 'short']\r\n```\r\n参数maxsplit表示从左到右分割多少次，默认为-1，表示分割所有分隔符\r\n```\r\nIn[]：\r\ns = \"life        is short\"\r\ns.split(maxsplit=1)\r\nOut[]：\r\n['life', 'is short']\r\n```\r\n分隔符可以是任意字符串\r\n```\r\nIn[]：\r\ns = \"life        is short\"\r\ns.split('is')\r\nOut[]：\r\n['life        ', ' short']\r\n```\r\n### str.rsplit\r\n```\r\nIn[]：\r\nhelp(str.rsplit)\r\nOut[]：\r\nHelp on method_descriptor:\r\nrsplit(self, /, sep=None, maxsplit=-1)\r\n    Return a list of the words in the string, using sep as the delimiter string.\r\n      sep\r\n        The delimiter according which to split the string.\r\n        None (the default value) means split according to any whitespace,\r\n        and discard empty strings from the result.\r\n      maxsplit\r\n        Maximum number of splits to do.\r\n        -1 (the default value) means no limit.\r\n    Splits are done starting at the end of the string and working to the front.\r\n```\r\nrsplit就是从右往左分割的\r\n### str.splitlines\r\n```\r\nIn[]：\r\nhelp(str.splitlines)\r\nOut[]：\r\nHelp on method_descriptor:\r\nsplitlines(self, /, keepends=False)\r\n    Return a list of the lines in the string, breaking at line boundaries.\r\n    Line breaks are not included in the resulting list unless keepends is given and\r\n    true.\r\n```\r\nsplitlines()方法比较简单，但是很实用，就是在读文件的时候，可以快速分割行\r\n按行分割，并且返回值不带换行符\r\n```\r\nIn[]：\r\ns = '''life\r\nis\r\nshort\r\n'''\r\ns.splitlines()\r\nOut[]：\r\n['life', 'is', 'short']\r\n```\r\n按行分割，并且返回值带换行符\r\n```\r\nIn[]：\r\ns = '''life\r\nis\r\nshort\r\n'''\r\ns.splitlines(True)\r\nOut[]：\r\n['life\\n', 'is\\n', 'short\\n']\r\n```\r\n### str.partition\r\n```\r\nIn[]：\r\nhelp(str.partition)\r\nOut[]：\r\nHelp on method_descriptor:\r\npartition(self, sep, /)\r\n    Partition the string into three parts using the given separator.\r\n    This will search for the separator in the string.  If the separator is found,\r\n    returns a 3-tuple containing the part before the separator, the separator\r\n    itself, and the part after it.\r\n    If the separator is not found, returns a 3-tuple containing the original string\r\n    and two empty strings.\r\n```\r\npartition其实就是split的指定分隔符，maxsplit=1的特殊版本\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.partition(' ')\r\nOut[]：\r\n('life', ' ', 'is short')\r\n```\r\n* 总是返回一个三元组（由三个元素构成的）\r\n* 按照传入的分隔符分割一次\r\n* 返回结果是head,sep,tail\r\nrpartition是partition从右往左的版本\r\n通常在对配置文件做操作的时候，我们会用partition\r\n## 大小写转换\r\n### str.upper & str.lower\r\n```\r\nIn[]：\r\ns = 'tEst'\r\ns.upper()\r\nOut[]：\r\n'TEST'\r\n```\r\n```\r\nIn[]：\r\ns = 'tEst'\r\ns.lower()\r\nOut[]：\r\n'test'\r\n```\r\nupper和lower两个方法都是**原地不修改，有返回值**\r\n### str.swapcase\r\n大小写互换，**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns = 'tEst'\r\ns.swapcase()\r\nOut[]：\r\n'TeST'\r\n```\r\n## 排版\r\n### str.title\r\n每个单词首字母大写，**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns = 'tEst hello'\r\ns.title()\r\nOut[]：\r\n'Test Hello'\r\n```\r\n### str.capitalize\r\n一句话的首字母大写，**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.capitalize()\r\nOut[]：\r\n'Life is short'\r\n```\r\n### str.center\r\n在指定支付长度中居中，**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns = 'test'\r\ns.center(100)\r\nOut[]：\r\n'                                                test                                                '\r\n```\r\n```\r\nIn[]：\r\ns = 'test'\r\ns.center(100,'-')\r\nOut[]：\r\n'------------------------------------------------test------------------------------------------------'\r\n```\r\n### str.zfill\r\n用0补足，**原地不修改，有返回值**\r\n```\r\nIn[]：\r\ns = 'tEst'\r\ns.zfill(50)\r\nOut[]：\r\n'0000000000000000000000000000000000000000000000tEst'\r\n```\r\n## 修改\r\n### str.replace\r\nreplace返回一个新的字符串，原地不修改，有返回值\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.replace('short','long')\r\nOut[]：\r\n'life is long'\r\n```\r\n### str.strip\r\n去除字符串前后的空格\r\n```\r\nIn[]：\r\ns = '   life is short   '\r\ns.strip()\r\nOut[]：\r\n'life is short'\r\n```\r\n其实strip去除的是空白字符，不只是空格\r\n```\r\nIn[]：\r\ns = '\\t\\n\\r life is short '\r\ns.strip()\r\nOut[]：\r\n'life is short'\r\n```\r\n而且strip可以去除指定的字符，但是仅限于前后\r\n```\r\nIn[]：\r\ns = '#-#   life is short  #-#'\r\ns.strip('#')\r\nOut[]：\r\n'-#   life is short  #-'\r\n```\r\n还可以去除多个字符，按照先后顺序\r\n```\r\nIn[]：\r\ns = '###  H is happy H #'\r\ns.strip('#H ')\r\nOut[]：\r\n'is happy'\r\n```\r\n### str.lstrip\r\n只移除左边的\r\n```\r\nIn[]：\r\ns = '###life is short'\r\ns.lstrip('#')\r\nOut[]：\r\n'life is short'\r\n```\r\n只移除右边的\r\n```\r\nIn[]：\r\ns = 'life is short###'\r\ns.rstrip('#')\r\nOut[]：\r\n'life is short'\r\n```\r\n### str.ljust\r\n用来填充字符，原字符串在左边\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.ljust(50)\r\nOut[]：\r\n'life is short                                     '\r\n```\r\n可以指定填充字符\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.ljust(50,'$')\r\nOut[]：\r\n'life is short$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'\r\n```\r\n### str.rjust\r\n用来填充字符，原字符串在右边\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.rjust(50,'$')\r\nOut[]：\r\n'$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$life is short'\r\n```\r\n## 查找\r\n### str.find\r\n从左往右查找，找到第一个子串，返回子串首字母的索引\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.find('f')\r\nOut[]：\r\n2\r\n```\r\n当子串不存在的时候返回-1\r\n```\r\nIn[]：\r\ns = 'life is short'\r\ns.find('F')\r\nOut[]：\r\n-1\r\n```\r\nstart参数和stop参数是开始查找的索引和结束查找的索引，左闭右开，不包含end参数，end=-1代表的就是最后\r\n### str.rfind\r\nfind从右往左的版本\r\n```\r\nIn[]：\r\ns = 'life is funny'\r\ns.rfind('f')\r\nOut[]：\r\n8\r\n```\r\n### str.index\r\nindex查找，子串不存在时，抛出ValueError\r\nfind查找时，子串不存在，返回-1\r\n这是index和find的唯一区别\r\n### str.rindex\r\nrindex是index从右往左的版本\r\n### str.count\r\n计算参数在字符串中的个数，当count计算的值不存在的时候返回0\r\ncount同样也是有start参数和end参数的\r\n```\r\nIn[]：\r\ns = '###life is funny###'\r\ns.count('#')\r\nOut[]：\r\n6\r\n```\r\n### str.startswith\r\n判断字符串是否以某个前缀开始，返回结果是bool值\r\nstart参数，end参数和find一样\r\n```\r\nIn[]：\r\ns = '###life is funny###'\r\ns.startswith('#')\r\nOut[]：\r\nTrue\r\n```\r\n### str.endswith\r\nendswith判断字符串是否以某个后缀结束，返回bool\r\nstart参数，end参数和find一样\r\n```\r\nIn[]：\r\ns = '###life is funny###'\r\ns.endswith('#')\r\nOut[]：\r\nTrue\r\n```\r\n### is*\r\nis\\*的意思就是，字符串的方法里有一串以is开头的方法，代表的意思就是“是否是xxx”\r\nisalnum判断是否是只含有字母\r\n```\r\nIn[]：\r\ns = 'qwer'\r\ns.isalnum()\r\nOut[]：\r\nTrue\r\n```\r\nisdecimal判断是否是数字\r\n```\r\nIn[]：\r\ns = '12345'\r\ns.isdecimal()\r\nOut[]：\r\nTrue\r\n```\r\nisidentifier判断是否是字母或者下划线开头，且包含字母数字和下划线\r\n```\r\nIn[]：\r\ns = '_is1'\r\ns.isidentifier()\r\nOut[]：\r\nTrue\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python字符串及其常用操作",
        "date": "2019-08-29 15:04:43",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-zi-fu-chuan-ji-qi-chang-yong-cao-zuo"
    },
    {
      "content": "元组：tuple\r\ntuple和list非常相似，但是tuple一旦初始化就不能修改\r\ntuple获取元素的方法与list一样，通过索引获取\r\n定义一个空的tuple：\r\n```\r\nt = ()\r\n```\r\n但是要定义一个只有一个元素的tuple，必须加一个逗号，来消除歧义\r\n```\r\nt = (1,)\r\n```\r\n“可变的”tuple\r\n```\r\nIn[]：\r\nt = ('a','b',['python','java'])\r\nprint(t)\r\nt[2][1] = 'php'\r\nprint(t)\r\nOut[]：\r\n('a', 'b', ['python', 'java'])\r\n('a', 'b', ['python', 'php'])\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python元组及其常用操作",
        "date": "2019-08-29 13:57:16",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-yuan-zu-ji-qi-chang-yong-cao-zuo"
    },
    {
      "content": "# 概念\r\n在其他语言里，会叫这种数据类型为数组，array，在python里，我们叫列表，list\r\n列表是一种数据结构\r\n列表是一个序列，用于顺序的存储数据。\r\n序列是python中最基本的数据结构。\r\n序列中的每个元素都分配一个数字：索引\r\n```\r\nl = list()\r\nl = []\r\nl = [1,2,3]\r\nl = list(range(1,10))\r\n```\r\n通常在定义列表的时候用\\[]，在转化可迭代对象为列表的时候用list函数\r\n# 访问列表\r\n定义一个1-9的列表\r\n```\r\nl = list(range(1,10))\r\n```\r\n通过下标访问，下标从0开始\r\n```\r\nl[0]\r\n```\r\n当下标超出范围时，会抛出IndexError\r\n```\r\nl[100]\r\n```\r\n负数索引从右边开始，并且索引从-1开始\r\n## list.index\r\n也可以通过help函数查看所有方法的函数签名，也就是函数说明\r\n```\r\nIn[]：help(list.index)\r\nOut[]：\r\nHelp on method_descriptor:\r\nindex(self, value, start=0, stop=9223372036854775807, /)\r\n    Return first index of value.\r\n    Raises ValueError if the value is not present.\r\n```\r\n这里函数签名中，stop有个默认值，也就是到列表哪一个位置结束，这也是它的最大值了，超出了可能就内存溢出。\r\n\"list.index\"方法返回查找到的第一个索引\r\n```\r\nl = list(range(1,10))\r\nl.index(4)\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.index(2)\r\nnew_l.index(2,2,3)\r\nnew_l.index(2,-1)\r\nnew_l.index(2,-4,-1)\r\n```\r\nlist.index的start和end参数可以为负数，但是在查找过程中还是从左到右的顺序\r\n当查找不到元素时，抛出错误ValueError。\r\n### list.index函数解读\r\n实现list.index函数：\r\n```\r\ndef index(lst,val,start=0,end=-1):\r\n    i = start\r\n    for x in lst[start:end]:\r\n        if x == val:\r\n            return i\r\n        i += 1\r\n    raise ValueError()\r\n```\r\n## list.count\r\n查看一下list.count的函数签名\r\n```\r\nIn[]：help(list.count)\r\nOut[]：\r\nHelp on method_descriptor:\r\ncount(self, value, /)\r\n    Return number of occurrences of value.\r\n```\r\nlist.count，统计你要查询的字符在列表里出现的次数\r\n```\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.count(5)\r\nnew_l.count(10)\r\n```\r\n### list.count函数解读\r\n实现list.count函数：\r\n```\r\ndef count(lst,value):\r\n    c = 0\r\n    for x in lst:\r\n        if x == value:\r\n            c += 1\r\n    return c\r\n```\r\n## 总结\r\n* list通过索引访问元素\r\n* index方法根据值返回第一个索引\r\n* count方法返回元素在列表里的个数\r\n\r\nindex和count的时间复杂度是O(n)\r\n# 列表修改\r\n通过索引的方式进行赋值即可\r\n```\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l[2] = 5\r\nprint(new_l)\r\nOut[]：\r\n[1, 2, 5, 2, 4, 3, 5]\r\n```\r\n超出范围还是会抛出IndexError\r\n```\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l[10] = 10\r\nOut[]：\r\nIndexError                                Traceback (most recent call last)\r\n<ipython-input-3-daf879895697> in <module>\r\n      1 new_l = [1,2,3,2,4,3,5]\r\n----> 2 new_l[10] = 10\r\nIndexError: list assignment index out of range\r\n```\r\n# 列表增加\r\n## list.append\r\n先用help函数看下它的函数签名\r\n```\r\nIn[]：\r\nhelp(list.append)\r\nOut[]：\r\nHelp on method_descriptor:\r\nappend(self, object, /)\r\n    Append object to the end of the list.\r\n```\r\nappend**原地修改list，返回值是None**,直接在最后加一位，我们称之为追加\r\n```\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.append(99)\r\nprint(new_l)\r\nOut[]：\r\n[1, 2, 3, 2, 4, 3, 5, 99]\r\n```\r\n## list.insert\r\n在第i个元素前插入e\r\n```\r\nIn[]：\r\nhelp(list.insert)\r\nOut[]：\r\nHelp on method_descriptor:\r\ninsert(self, index, object, /)\r\n    Insert object before index.\r\n```\r\n```\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.insert(1,99)\r\nprint(new_l)\r\nOut[]：\r\n[1, 99, 2, 3, 2, 4, 3, 5]\r\n```\r\n**当越界的时候，自动往左或往右插入该值，这点非常重要，它并不会报错**\r\n```\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.insert(100,99)\r\nprint(new_l)\r\nOut[]：\r\n[1, 2, 3, 2, 4, 3, 5, 99]\r\nIn[]：\r\nnew_l = [1,2,3,2,4,3,5]\r\nnew_l.insert(-100,99)\r\nprint(new_l)\r\nOut[]：\r\n[99, 1, 2, 3, 2, 4, 3, 5]\r\n```\r\nappend和insert的效率：\r\n* append的时间复杂度是O(1)，常数时间，效率和数据的规模无关\r\n* insert的时间复杂度是O(n)，线性时间，效率和数据规模线性相关\r\n\r\n**尽量使用append**\r\n## list.extend\r\nextend将任意可迭代对象追加到数据的末尾，**原地修改，返回None**\r\n```\r\nIn[]：\r\nhelp(list.extend)\r\nOut[]：\r\nHelp on method_descriptor:\r\nextend(self, iterable, /)\r\n    Extend list by appending elements from the iterable.\r\n```\r\n值得注意的是，extend是把可迭代对象里的每一个值循环append到list里去，而不是像append，直接把一整个对象追加到列表的队尾\r\n* append操作单个元素\r\n* extend操作可迭代对象\r\n\r\n对比栗子：\r\n```\r\nIn[]：\r\nnew_l = [0,1,2]\r\nnew_l.append([1,2,3])\r\nprint(new_l)\r\nOut[]：\r\n[0, 1, 2, [1, 2, 3]]\r\nIn[]：\r\nnew_l = [0,1,2]\r\nnew_l.extend([1,2,3])\r\nprint(new_l)\r\nOut[]：\r\n[0, 1, 2, 1, 2, 3]\r\n```\r\n**list.extend经常用在两个列表的相加上**\r\n## list + list\r\n两个列表的相加还可以直接用加号\r\n```\r\nIn[]：\r\nl = [0,1,2,3,4]\r\na = l + ['a','b','c']\r\nprint('a:',a)\r\nprint('l:',l)\r\nOut[]：\r\na: [0, 1, 2, 3, 4, 'a', 'b', 'c']\r\nl: [0, 1, 2, 3, 4]\r\n```\r\n**这种方法有返回值，但是不修改list本身，返回一个新的list**，这种操作叫list的连接操作\r\n# 列表删除\r\n## list.remove\r\n```\r\nIn[]：\r\nhelp(list.remove)\r\nOut[]：\r\nHelp on method_descriptor:\r\nremove(self, value, /)\r\n    Remove first occurrence of value.\r\n    Raises ValueError if the value is not present.\r\n```\r\n删除第一个匹配的元素\r\n```\r\nIn[]：\r\nl = [1,2,3,2,3,4,3,5,3,4]\r\nl.remove(2)\r\nprint(l)\r\nOut[]：\r\n[1, 3, 2, 3, 4, 3, 5, 3, 4]\r\n```\r\n**原地修改，返回None，根绝值删除元素**\r\n当值不存在时，抛出ValueError\r\n```\r\nIn[]：\r\nl = [1,2,3,2,3,4,3,5,3,4]\r\nl.remove(10)\r\nOut[]：\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-5-13fc432ba077> in <module>\r\n      1 l = [1,2,3,2,3,4,3,5,3,4]\r\n----> 2 l.remove(10)\r\nValueError: list.remove(x): x not in list\r\n```\r\n## list.pop\r\n```\r\nIn[]：\r\nhelp(list.pop)\r\nOut[]：\r\nHelp on method_descriptor:\r\npop(self, index=-1, /)\r\n    Remove and return item at index (default last).\r\n    Raises IndexError if list is empty or index is out of range.\r\n```\r\n不传入参数，则默认返回并删除最后一个值\r\n传入index参数，返回并删除index所在的值\r\n```\r\nIn[]：\r\nl = [3,2,4,3,5,3,4]\r\nl.pop(3)\r\nprint(l)\r\nOut[]：\r\n3\r\n[3, 2, 4, 5, 3, 4]\r\n```\r\n**注意：这个传入的参数是index，不是元素的值**\r\n当索引不存在时，抛出IndexError\r\n```\r\nIn[]：\r\nl = [3,2,4,3,5,3,4]\r\nl.pop(100)\r\nOut[]：\r\nIndexError                                Traceback (most recent call last)\r\n<ipython-input-10-85aba9b20ee8> in <module>\r\n      1 l = [3,2,4,3,5,3,4]\r\n----> 2 l.pop(100)\r\nIndexError: pop index out of range\r\n```\r\n这里需要注意几点：\r\n* pop不传递index参数，时间复杂度是O(1)\r\n* pop传递index参数，时间复杂度是O(n)\r\n* pop根据索引删除元素，并且返回删除的元素\r\n* remove根据值删除元素，返回None\r\n\r\n## list.clear\r\n```\r\nIn[]：\r\nhelp(list.clear)\r\nOut[]：\r\nHelp on method_descriptor:\r\nclear(self, /)\r\n    Remove all items from list.\r\n```\r\n删除所有元素\r\n```\r\nIn[]：\r\nl = [3,2,3,5,3,4]\r\nl.clear()\r\nprint(l)\r\nOut[]：\r\n[]\r\n```\r\n使用clear后，列表对象还存在，只是里面的值都被清空了\r\n# 其它操作\r\n## 求list的长度\r\nlen(l)\r\n```\r\nIn[]：\r\nl = [3,2,3,5,3,4]\r\nlen(l)\r\nOut[]：\r\n6\r\n```\r\n## 反转列表\r\nl.reverse()\r\n```\r\nIn[]：\r\nl = [0,1,2,3,4,5,6]\r\nl.reverse()\r\nprint(l)\r\nOut[]：\r\n[6, 5, 4, 3, 2, 1, 0]\r\n```\r\n## 列表排序\r\nl.sort()\r\n```\r\nIn[]：\r\nl = [2,5,3,6,1,4,8,9]\r\nl.sort()\r\nprint(l)\r\nOut[]：\r\n[1, 2, 3, 4, 5, 6, 8, 9]\r\n```\r\n**原地修改，返回None**\r\n**逆序排序，l.sort(reverse=True)**\r\n```\r\nIn[]：\r\nl = [2,5,3,6,1,4,8,9]\r\nl.sort(reverse=True)\r\nprint(l)\r\nOut[]：\r\n[9, 8, 6, 5, 4, 3, 2, 1]\r\n```\r\n## 列表拷贝\r\n### 引用传递\r\n```\r\nIn[]：\r\na = [1,2,3]\r\nb = a\r\nprint(b)\r\nb[1] = 99\r\nprint(b)\r\nprint(a)\r\nOut[]：\r\n[1, 2, 3]\r\n[1, 99, 3]\r\n[1, 99, 3]\r\n```\r\n### 浅复制（浅拷贝）\r\n```\r\nIn[]：\r\nl = [1,2,3,4,5]\r\nl2 = l.copy()\r\nl2[0] = 'a'\r\nprint(l)\r\nprint(l2)\r\nOut[]：\r\n[1, 2, 3, 4, 5]\r\n['a', 2, 3, 4, 5]\r\n```\r\n如果列表存在嵌套列表\r\n```\r\nIn[]：\r\nl = [1,[1,2,3],4]\r\nl2 = l.copy()\r\nl2[1][1] = 'a'\r\nprint(l2)\r\nprint(l)\r\nOut[]：\r\n[1, [1, 'a', 3], 4]\r\n[1, [1, 'a', 3], 4]\r\n```\r\n### 深复制（深拷贝）\r\n使用深拷贝需要引入copy模块，使用deepcopy\r\n```\r\nIn[]：\r\nfrom copy import deepcopy\r\nl = [1, [1, 'a', 3], 4]\r\nl2 = deepcopy(l)\r\nl2[1][1] = 'b'\r\nprint(l2)\r\nprint(l)\r\nOut[]：\r\n[1, [1, 'b', 3], 4]\r\n[1, [1, 'a', 3], 4]\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python列表及其常用操作",
        "date": "2019-08-28 14:07:15",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-nei-zhi-shu-ju-jie-gou"
    },
    {
      "content": "# 常量变量 & 类型系统\r\n## 常量变量\r\n常量：一旦赋值，就不能改变它的值。也就是说不能对它进行重新赋值。\r\n变量：是一个名字，在赋值符号的左边，这个名字可以指代赋值符号右边的内容。\r\n注意：Python不存在常量。因为Python一切皆对象，Python赋值即定义。\r\n## 类型系统\r\npython是门强类型的动态语言，但它同时又是一门解释性语言。\r\n那么作为强类型语言，python就有自己的类型系统，python的类型系统分为基本类型和内置数据结构。\r\n基本类型分为：\r\n* int\r\n* float\r\n* bool\r\n* None\r\n\r\nstr、list、dict等在官方文档中查到，隶属于：built-in structure。\r\n内置数据结构分为：\r\n* str\r\n* list\r\n* tuple\r\n* set\r\n* dict\r\n* bytes\r\n* bytearray\r\n\r\n动态语言指一个变量的类型可以被多次修改、赋值。\r\n而在java、c#这种静态语言中，一旦定义了一个变量\r\n```\r\nstring strA = 'a'\r\n```\r\n就无法改变它的类型了，只能改变值。\r\n# 基本数据类型\r\n## 整型和浮点型\r\n在python2里区分整型和长整型，python3里不区分，只有整型。\r\n对于int来说，不存在溢出。\r\n但float会溢出，会损失精度，这也就是我们常说的精度失效。\r\n举个简单的栗子：\r\n```\r\nIn[1]：3.3 * 6\r\nOut[1]：19.799999999999997\r\n```\r\n### 为什么会有精度失效\r\n因为计算机都是用二进制表示的，那么势必会存在0和1之间的数字没法表示。\r\n### 二进制小数转十进制小数\r\n采用方法：按权展开求和法\r\n举个栗子：将101.111(2)这个二进制小数转换成十进制数。\r\n计算：1*(2^2)+0*(2^1)+1*(2^0)+1*(2^(-1))+1*(2^(-2))+1*(2^(-3))=5.875\r\n### 十进制小数转二进制小数\r\n十进制数的整数位是二进制数的整数位，十进制数的小数位是二进制数的小数位\r\n假如有小数111.4(10)，进行计算\r\n小数位采用“乘二取整法”（顺序排列），取整就是取整数位上的数字\r\n| 乘二 |  取整 |\r\n| - | - |\r\n| 0.4\\*2=0.8 | 0 |\r\n| 0.8\\*2=1.6 | 1 |\r\n| 0.6\\*2=1.2 | 1 |\r\n| 0.2\\*2=0.4 | 0 |\r\n| 0.4\\*2=0.8 | 0 |\r\n| 0.8\\*2=1.6 | 1 |\r\n| 0.6\\*2=1.2 | 1 |\r\n| 0.2\\*2=0.4 | 0 |\r\n经过计算发现出现了循环，0.01100110...(循环0110)\r\n整数位采用“除二取余法”（逆序排列）\r\n| 除二 | 商 | 余数 |\r\n| - | - | - |\r\n| 111/2 | 55 | 1 |\r\n| 55/2 | 27 | 1 |\r\n| 27/2 | 13 | 1 |\r\n| 13/2 | 6 | 1 |\r\n| 6/2 | 3 | 0 |\r\n| 3/2 | 1 | 1 |\r\n| 1/2 | 0 | 1 |\r\n所以整数位是1101111\r\n最终结果是整数位和小数位合并1101111.01100110......\r\n### 代码\r\n从代码角度出发，如何规避这类情况？那就要用到经常提到的一个概念：“精确到小数点后面多少位”\r\n```\r\nfrom decimal import Decimal\r\nfrom decimal import getcontext\r\ngetcontext().prec = 8\r\nIn[]：Decimal(3.3) * Decimal(6)\r\nOut[]：Decimal('19.800000')\r\n```\r\n## None\r\nNone就是一个类型，在js里面有undefined和null，但是python只有一个None。\r\nNone既不是空字符串，也不是未定义\r\nNone在判断语句中位False，但None不等于False\r\n```\r\nIn[]：None == False\r\nOut[]：False\r\n```\r\n## Bool\r\nBool就是True or False。\r\n## 总结\r\n基本数据类型一共有4种，int、float、bool、None\r\n# 运算符\r\n## 算数运算符\r\n* \\+\r\n* \\-\r\n* \\*\r\n* \\/\r\n* \\//\r\n* \\**\r\n* \\%\r\n\r\n以上就是python运算符，但是要注意：只能对int和float做运算。\r\n特别说明：\r\n/运算符在python3是自然除，python2是整除\r\n## 比较运算符\r\n* \\>\r\n* \\<\r\n* \\=\r\n* \\!=\r\n* \\>=\r\n* \\<=\r\n\r\n所有比较运算符的返回值都是bool类型\r\n## 逻辑运算符\r\n* and\r\n* or\r\n* not\r\n\r\n逻辑运算符的两边必须是True或False\r\n注意：逻辑运算符的短路\r\nor运算，只要执行到第一个位true的时候之后就不执行了。\r\n## 成员运算符\r\n* in\r\n* not in\r\n\r\n## 身份运算符\r\n* is\r\n* is not\r\n\r\n## 位运算符\r\n* \\<<\r\n* \\>>\r\n* &\r\n* |\r\n* ^ 异或\r\n\r\n位运算符用在哪里呢？\r\n### 判断奇偶数\r\n我们可以利用&运算符的特性来判断二进制数最后一位是0还是1。\r\n用if((a&1) == 0)代替if(a%2 == 0)来判断a是不是偶数。\r\n### 交换两个数\r\n先了解一下^的几个特性\r\n* a^a = 0\r\n* a^0 = a\r\n* (a^b)^c = a^(b^c)\r\n\r\n交换两个数的方法为：\r\n```\r\na ^= b\r\nb ^= a\r\na ^= b\r\n```\r\n从数学角度分析一下：\r\na = a ^ b\r\nb = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a\r\na = a ^ b = (a ^ b) ^ b = (a ^ a) ^ b = b ^ 0 = b\r\n## 赋值运算符\r\n* i += 3\r\n* i \\*= 3\r\n\r\n所有的算术运算符都可以和赋值运算符一起使用。\r\n# 表达式 & 程序结构\r\n## 表达式 & 语句\r\n表达式：常量/变量和运算符一起构成，表达式有返回值\r\n语句：关键字和表达式一起构成，语句没有返回值\r\n## 顺序结构\r\n就是代码从上到下，一行一行执行\r\n## 分支结构\r\n### 单分支\r\n单分支只有一个操作，条件成立去做操作，然后结束，否则直接结束。\r\n```\r\na = 5\r\nif a < 10:\r\n    print('a less than 10')\r\nprint(a)\r\n```\r\n### 双分支\r\n双分支就是当条件不成立的时候还多了一个操作，方便做逻辑处理。\r\n```\r\na = 5\r\nif a < 10:\r\n    print('a less than 10')\r\nelse:\r\n    print('a is not less than 10')\r\nprint(a)\r\n```\r\n双分支结构永远只有一个条件会被执行\r\n### 嵌套\r\n嵌套的意思就是，在if里面还可以有if\r\n通过结构嵌套实现多分支\r\n```\r\na = 5\r\nif a < 10:\r\n    print('a less than 10')\r\nelse:\r\n    if a < 20:\r\n        print('10 <= a < 20')\r\n    else:\r\n        print('a is not less than 10')\r\nprint(a)\r\n```\r\n### 关键字elif\r\n```\r\na = 5\r\nif a < 10:\r\n    print('a less than 10')\r\nelif a < 20:\r\n    print('10 <= a < 20')\r\nelse:\r\n    print('a is not less than 10')\r\nprint(a)\r\n```\r\n对于分支结构来说，总结一下就是：\r\n1. 分支结构永远只有1个或者0个分支会被执行\r\n2. 分支结构中所有条件是互斥的\r\n3. 条件只能是bool类型或者可以隐式转换为bool类型\r\n## 循环结构\r\n### while\r\nwhile循环需要一个条件支撑，如果条件为True，循环将继续。\r\n### for in\r\npython的for循环和其他语言不一样，在for关键字里实现了一个迭代协议，通过迭代协议完成了对可迭代对象的循环。\r\n#### 提前终止\r\n当在for循环体内，遇到break关键字的时候，将会结束本层循环，注意不是本次，是本层\r\n如果是两个for循环,那么就会退出本层循环，进入上层循环的下一次循环中\r\n```\r\nfor i in range(3):\r\n    for j in range(5):\r\n        print('j:' + str(j))\r\n        if j % 2 == 0:\r\n            print('i:',i,'j:',j)\r\n            break\r\n```\r\n#### 跳过\r\ncontinue是跳过本次循环，继续下一次循环，**注意这里是继续同一层的下一次循环**\r\n```\r\nfor i in range(0,3):    \r\n    if i % 2 != 0:\r\n        print(i)\r\n        continue\r\n```\r\n### else子句\r\n在python中，for循环还有一个其他语言没有的关键字，else\r\n这个else不是if的else，而是for的else。只有当for循环的主体循环全部结束后，才会去执行else语句。\r\n举个栗子：\r\n```\r\nIn[0]:\r\nfor i in range(10):\r\n    pass\r\nelse:\r\n    print('ok')\r\nOut[0]:ok\r\n```\r\n如果循环体被break了呢？\r\n```\r\nIn[0]:\r\nfor i in range(10):\r\n    break\r\nelse:\r\n    print('ok')\r\nOut[0]:\r\n```\r\n如果是continue呢？\r\n```\r\nIn[0]:\r\nfor i in range(10):\r\n    continue\r\nelse:\r\n    print('ok')\r\nOut[0]:ok\r\n```\r\n结论：**当循环没有提前退出时，会执行else子句**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Python基本语法",
        "date": "2019-08-27 13:51:40",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-ji-ben-yu-fa"
    },
    {
      "content": "# Git配置\r\nGit安装完成后需要配置个人的用户名称和邮件地址\r\n```\r\ngit config --global user.name \"yanghang\"\r\ngit config --global user.email yanghang0214@qq.com\r\n```\r\n查看配置信息\r\n```\r\ngit config --list\r\n```\r\n# Git创建仓库\r\n初始化Git仓库\r\n```\r\ngit init\r\n```\r\n将文件添加到缓存，例如添加两个文件：\r\n```\r\ngit add <file1> <file2> \r\n```\r\n或者添加所有文件，可以使用\r\n```\r\ngit add .\r\n```\r\n查看文件是否添加成功：\r\n```\r\ngit status\r\ngit status -s\r\n```\r\n将缓存区内容添加到仓库中：\r\n```\r\ngit commit -m '本次提交的说明'\r\n```\r\n查看文件修改了哪些内容：\r\n```\r\ngit diff readme.txt \r\n```\r\n查看git提交修改的日志：\r\n```\r\ngit log\r\n```\r\nGit版本回退，在Git中用HEAD表示当前版本，上个版本是HEAD\\^,上上个版本是HEAD\\^^，往上100个写成HEAD\\~100：\r\n```\r\ngit reset --hard HEAD^\r\n```\r\n要重返未来需要查看命令历史\r\n```\r\ngit reflog\r\n```\r\n# Git添加远程仓库\r\n**创建SSH Key**\r\n使用自己的邮件地址，一路回车使用默认值。完成后可以在**用户主目录**里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，id_rsa是私钥，id_rsa.pub是公钥。\r\n```\r\nssh-keygen -t rsa -C \"youremail@example.com\"\r\n```\r\n**在GitHub添加key**\r\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴**id_rsa.pub**文件的内容，点“Add Key”，你就应该看到已经添加的Key。\r\n**关联远程仓库**\r\n远程库的名字就是origin，这是Git默认的叫法，也可以改成别的\r\n```\r\ngit remote add origin git@github.com:yh0214/grideasourcecode.git\r\n```\r\n**本地推送至远程库**\r\n首先添加内容到缓存：git add <file1>，然后由缓存添加内容到仓库：git commit -m '本次提交的说明'；使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，可以使用命令git push origin master推送最新修改\r\n```\r\ngit push -u origin master\r\ngit push origin master\r\n```\r\n**从远程库克隆至本地**\r\n```\r\ngit clone git@github.com:yh0214/grideasourcecode.git\r\n```\r\n**删除github上文件**\r\n```\r\ngit rm -r --cached 文件夹名称\r\ngit commit -m 'delete 文件夹名称 dir'\r\ngit push -u origin master\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Git",
        "date": "2019-08-27 08:31:42",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "Python",
      "slug": "b-HvOq5Zt",
      "used": false
    }
  ],
  "menus": []
}